# 异常处理

## 异常分类

在Java中，`Throwable` 是所有错误和异常的超类。它有两个主要的子类： `Error` 和 `Exception` 。

* `Error`：由于系统故障或资源耗尽等无法恢复的错误，通常表示虚拟机错误、内存不足、栈溢出等情况。

* `Exception`：由于程序代码出现了异常情况而导致的错误，包括 `IOException` 、 `ClassNotFoundException` 、 `RuntimeException` 等等。
    * `RuntimeException`：运行时异常，不需要在方法中进行声明或者捕获，比如NullPointerException和ArrayIndexOutOfBoundsException等。

    * `CheckedException`：需要在方法中进行声明或者捕获的异常，比如IOException和ClassNotFoundException等，一般都是在程序中对外部资源进行操作时可能出现的异常。

UncheckedException是指不需要在方法中进行声明或者捕获的异常，比如NullPointerException和ArrayIndexOutOfBoundsException等，一般都是程序本身代码问题导致的异常。

### 异常处理语句

在Java中，异常处理是一个重要的概念。在程序运行期间，可能会出现各种各样的异常情况，例如：用户输入了非法的数据、网络连接中断等等。如果不加以处理，这些异常将导致程序崩溃。为了保证程序的健壮性和可靠性，Java引入了异常处理机制，其中 try/catch语句是其中的核心。

try/catch语句允许程序员在代码中识别和处理异常。try块包含一段代码，用于监视可能会抛出异常的代码块。如果try块中的代码抛出了异常，则Java运行时系统会抛出异常，并且程序会停止运行。catch块用于捕获这些异常，并进行相应的处理。

语法如下：

```csharp
try {
   // 监视可能会抛出异常的代码
} catch (ExceptionType1 e1) {
   // 处理 ExceptionType1 类型的异常
} catch (ExceptionType2 e2) {
   // 处理 ExceptionType2 类型的异常
} finally {
   // 无论是否抛出异常，finally中的代码总会被执行
}
```

在try块中，我们可以写一些可能会抛出异常的代码。当异常被抛出时，catch块中的代码将被执行。catch块中需要指定需要捕获的异常类型，以便Java运行时系统知道如何处理异常。

在try/catch语句中，还可以使用finally块。finally块中的代码无论是否抛出异常，都会被执行。通常，我们可以在finally块中释放资源，比如关闭打开的文件等等。

以下是一个简单的示例代码：

```java
import java.io.File;
import java.io.FileNotFoundException;
import java.util.Scanner;

public class ReadFile {
   public static void main(String[] args) {
      try {
         // 打开一个文件
         File file = new File("file.txt");

         // 读取文件
         Scanner scanner = new Scanner(file);
         while (scanner.hasNextLine()) {
            String line = scanner.nextLine();
            System.out.println(line);
         }

         // 关闭文件
         scanner.close();
      } catch (FileNotFoundException e) {
         System.out.println("文件未找到！");
      } finally {
         System.out.println("程序执行完毕！");
      }
   }
}
```

上述代码打开一个名为file.txt的文件，读取其中的内容并输出到控制台。如果文件不存在，则会捕获FileNotFoundException异常并输出错误信息。无论是否抛出异常，程序执行完毕后都会执行finally块中的代码。


throws：写在方法声明处，告诉调用者可能发生的异常，由调用者进行处理或继续向上抛出异常。

## equals
Java中的equals方法用于比较两个对象是否相等。它是Object类的一个实例方法，因此所有的Java类都继承了这个方法。默认情况下，equals方法将检查两个对象是否具有相同的引用，即它们是否指向内存中的相同对象。但是，很多时候我们需要比较两个对象的内容是否相等，而不仅仅是它们是否具有相同的引用。

在Java中，我们可以重写equals方法来实现自定义的对象比较方式。通常情况下，我们需要在自定义的类中重写equals方法，并比较每个实例变量是否相等。如果所有实例变量的值都相等，则两个对象被认为是相等的。例如，考虑下面的Person类：

```java
public class Person {
    private String name;
    private int age;

    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }

    @Override
    public boolean equals(Object o) {
        if (o == this) return true;
        if (!(o instanceof Person)) return false;
        Person p = (Person) o;
        return this.name.equals(p.name) && this.age == p.age;
    }
}
```

在这个例子中，我们重写了equals方法来比较Person对象的name和age属性。如果两个Person对象的name和age属性相同，equals方法将返回true，否则返回false。

注意，我们还需要覆盖hashCode方法，以便在使用Java集合类时正确地处理自定义对象。如果equals方法返回true，则hashCode方法必须返回相同的值。例如，我们可以使用以下实现：

```Java
@Override
public int hashCode() {
    return Objects.hash(name, age);
}
```

这将返回一个基于name和age属性的哈希码，这个哈希码可以被用来在Java集合类中存储对象。
# 04. Java高级类特性
## 封装
封装的核心思想是隐藏类的内部实现细节，只对外提供简单的接口，从而保护类的内部状态不受外部干扰，提高程序的安全性、可读性和可维护性。具体来说，封装主要包括以下两个方面：

* **隐藏数据**：使用private访问修饰符将类的成员变量封装起来，防止外部直接访问和修改数据。为了访问和修改这些数据，类需要提供公共的访问方法（getters）和修改方法（setters），这些方法可以对数据进行安全检查和处理，从外部访问和修改类的内部状态时，只能通过这些公共方法进行。

* **隐藏实现细节**：将类的实现细节封装起来，只对外部提供公共接口，避免外部直接访问和修改类的内部实现细节。这可以让类的实现更加灵活和可维护，可以在不影响外部接口的情况下，随时修改类的内部实现细节。
### 可见域
Java可见域指的是类的成员变量和方法的可见性范围，即==哪些地方可以访问它们==。Java中有四种可见域，分别是public、protected、default（默认）和private，它们按照可见性逐渐降低。

* ==public==可见域：使用public关键字修饰的成员变量和方法可以被任何类访问，无论是否在同一包中。这是最高级别的可见域。

* ==protected==可见域：使用protected关键字修饰的成员变量和方法可以被同一包中的类和其他包中的子类访问，但是不能被其他包中的非子类访问。

* ==default==（默认）可见域：没有使用任何访问修饰符的成员变量和方法，即默认可见域，只能被同一包中的类访问。

* ==private==可见域：使用private关键字修饰的成员变量和方法只能在当前类中访问，其他类无法访问。

:::col example
```java
package com.example;

public class Person {
    public String name;
    protected int age;
    int height;
    private String address;
    
    public Person(String name, int age, int height, String address) {
        this.name = name;
        this.age = age;
        this.height = height;
        this.address = address;
    }
    
    public void introduce() {
        System.out.println("My name is " + name + ".");
        System.out.println("I'm " + age + " years old.");
        System.out.println("My height is " + height + " cm.");
        System.out.println("My address is " + address + ".");
    }
}
```
在上面的代码中，Person类有四个成员变量name、age、height和address，分别使用了不同的可见域修饰。
* 其中，name使用了public可见域，可以被任何类访问；
* age使用了protected可见域，只能被同一包中的类和其他包中的子类访问；
* height使用了默认可见域，只能被同一包中的类访问；
* address使用了private可见域，只能在Person类内部访问。
:::

* private 同一个类中的代码可以操作private修饰的元素。
* public 任何地点的代码都可以操作public修饰的与元素。
* protected 子类中可以操作血脉传承中的元素
* 无关键字 同一个包下可以操作此类元素。 

## 继承

### 子类继承父类的构造函数
Java子类可以通过使用`super()`调用父类的构造函数来继承父类的构造函数。在子类的构造函数中使用`super()`，它会调用父类的无参构造函数。如果子类需要调用父类的有参构造函数，则需要使用`super(arguments)`，其中`arguments`是父类构造函数需要的参数列表。

```java
public class Animal {
    private String name;
    
    public Animal(String name) {
        this.name = name;
    }
    
    public String getName() {
        return this.name;
    }
}

public class Cat extends Animal {
    private int age;
    
    public Cat(String name, int age) {
        super(name); // 调用父类构造函数
        this.age = age;
    }
    
    public int getAge() {
        return this.age;
    }
}
```
:::col example
* 学生类作为父类，初中生和高中生作为子类。
    * 每个学生有姓名，学号，性别等属性。
    * 初中生所学3门课程，数学英语和物理，同时可以配置这三门课程成绩。
    * 高中生所学4门课程，数学英语和物理和化学，同时可以配置这4门课成绩。
* 学生都有一个方法评判总分
    * 初中生的总分满分300，\[200-250]普通，[250-300]优秀，其他差
    * 高中生的总分满分480，\[400-480]优秀，[320-400]普通，其他差
    * 初中生每门课成绩的范围是0~100
    * 高中生每门课成绩范围是0~120
    
要求在输入的过程中对成绩的合法性进行校验
各自成绩输入完毕后请打印学生的信息：姓名，性别，学号，以及对总分的评判

```java

```
:::

### 小结
1. extends 父类
2. 如果没有extends关键字，默认extends Object
3. 父类的什么元素可以被继承？
    * 任何可见域的属性都能被继承。
    * 方法的继承和可见域等价。
4. Java的继承是单继承，只有一个父类。
5. 继承的过程中小心构造器引发的故障
6. 重写override就是子类书写了一个和父类同名同参的方法。

## 重载
重载（Overload）：在一个类中定义多个方法，它们具有相同的名称但参数列表不同（==参数类型==或==个数==或==排列顺序==不同）的情况。

* 作用：定义多个具有相同功能但不同参数的方法，从而适应不同的需求和场景。

* 方法重载可以出现在同一个类中，也可以在父类和子类之间进行重载。

* Java中的方法重载的规则：
    * 方法名称必须相同；
    * 方法的参数列表必须不同。
    * 返回类型可以改变，但不能只改变返回类型。
    * 访问修饰符可以改变，但不能只改变修饰符。

在调用这些方法时，Java编译器会根据实际参数的类型和个数来选择合适的方法进行调用，这种机制称为方法重载。

## 重写
重写（Overriding）：指子类中定义了一个与父类中==同名、同参数列表、同返回类型==的方法，并且该方法的访问修饰符不低于父类方法的访问修饰符。
* 当调用该方法时，子类中的方法会覆盖父类中的同名方法，实现了对父类方法的重写。

重写方法必须遵循以下规则：

* 方法名、参数列表和返回类型必须与父类方法相同。
* 访问修饰符不能低于父类方法的访问修饰符。
* 子类方法抛出的异常类型必须是父类方法抛出异常类型的子类。
## 多态 (*Polymorphism*)

多态（Polymorphism）是面向对象编程（OOP）的一个重要概念。
1. 多态允许子类继承父类的成员
2. 允许重写（Override）父类的方法。
3. 在 Java 中，多态是通过继承、接口实现和方法重写来实现的。

Java 多态表现为一个接口、==父类引用指向不同子类对象==，而执行相同方法时，根据对象的实际类型执行相应子类的实现。这意味着，使用多态时，我们可以将子类对象视为父类对象，并调用父类中定义的方法，但实际执行的是子类重写的方法。

### 作用

1.  **代码可扩展性**：多态提高了代码的可扩展性。当我们需要添加新的子类时，只需要继承父类或实现接口，重写相应的方法，而不需要修改已有的方法调用。这样，我们可以轻松地扩展程序的功能，同时保持代码的稳定性。
    
2.  **代码复用**：多态允许我们重用父类的代码，减少了代码冗余。子类可以继承父类的属性和方法，只需要重写需要特殊处理的部分。这样，我们可以将通用的代码放在父类中，让子类继承和重用。
    
3.  **解耦合**：多态有助于减少类之间的耦合。当我们使用父类引用指向子类对象时，我们只需要关心父类中定义的方法，而不需要关心子类的具体实现。这样，我们可以将不同的类解耦，使代码更易于维护和修改。
    

::::col example

```java
// 父类
class Animal {
    void makeSound() {
        System.out.println("The animal makes a sound");
    }
}

// 子类
class Dog extends Animal {
    @Override
    void makeSound() {
        System.out.println("The dog barks");
    }
}

// 子类
class Cat extends Animal {
    @Override
    void makeSound() {
        System.out.println("The cat meows");
    }
}

public class Main {
    public static void main(String[] args) {
        Animal myAnimal = new Animal();
        Animal myDog = new Dog();
        Animal myCat = new Cat();

        myAnimal.makeSound(); // Output: The animal makes a sound
        myDog.makeSound();    // Output: The dog barks
        myCat.makeSound();    // Output: The cat meows
    }
}
```

在这个例子中，我们定义了一个父类 Animal 和两个子类 Dog 和 Cat。子类分别重写了父类的 makeSound() 方法。在 main 方法中，我们使用 Animal 类型的引用指向不同的子类对象，并调用 makeSound() 方法。根据对象的实际类型，Java 自动调用相应子类的 makeSound() 方法。这就是多态的概念和作用。
::::


### 父类引用指向子类对象
"父类引用指向子类对象"是 Java 面向对象编程中多态（Polymorphism）的一个关键概念。这意味着你可以将子类对象的引用赋值给父类类型的变量。这样，当使用这个父类类型的变量调用方法时，Java 会根据对象的实际类型（即子类类型）自动调用相应子类的实现。这种机制允许我们在编写程序时只关注父类接口，而不需要关心具体的子类实现。

举个例子：

```java
// 父类
class Shape {
    void draw() {
        System.out.println("Drawing a shape");
    }
}

// 子类
class Circle extends Shape {
    @Override
    void draw() {
        System.out.println("Drawing a circle");
    }
}

// 子类
class Square extends Shape {
    @Override
    void draw() {
        System.out.println("Drawing a square");
    }
}

public class Main {
    public static void main(String[] args) {
        // 父类引用指向子类对象
        Shape myShape1 = new Circle(); // Circle 对象赋值给 Shape 类型的变量
        Shape myShape2 = new Square(); // Square 对象赋值给 Shape 类型的变量

        myShape1.draw(); // Output: Drawing a circle
        myShape2.draw(); // Output: Drawing a square
    }
}
```

在这个例子中，我们定义了一个父类 Shape 和两个子类 Circle 和 Square。子类分别重写了父类的 draw() 方法。在 main 方法中，我们使用 Shape 类型的变量（myShape1 和 myShape2）分别指向 Circle 和 Square 对象。当我们调用 draw() 方法时，Java 根据对象的实际类型（即子类类型）自动调用相应子类的实现。这就是"父类引用指向子类对象"的概念。
## 内部类

## static
static修饰的元素:
1:类中某个属性，如果用static修饰，那么这个属性就从实例属性变成了类属性实例是对象实例的意思，原先这个属性属于某个对象，而现在这个属性属于这个类例如
public class Male{string name;
static char sex='男';
public Male(String name){this.name=name; }
Male m1=new Male("张三");
Male m2=new Male("李四");
m1和m2这两个男性对象，各自拥有自己的name属性，分别存放张三和李四两个对象实例内部但是类中定义的sex这个属性不是个体实例的，而是这个Male类的
这个属性只有一个，挂在类图纸中。所以用这个类创建的无论多少个对象都共享同一个sex
m1.sex='F';

static修饰的元素都是类图纸被载入档案室的过程中出现的，而此时还没有用图纸构造任何对象实例所以使用共享元素最好的方法，不是用对象名去引用此元素，而是用类名去引用
例如m1.sex不恰当，尽管合法，但不合理，应该用Male.sex描述更合适。


## 接口 *interface*
接口是一种抽象类型，它定义了一组方法，但不包含具体的实现。接口可以看作是一份协议或规范，规定了某些类必须实现哪些方法，以达到统一的行为规范。

Java中的接口是通过interface关键字来定义的。接口中的方法默认都是public abstract类型，也就是说不能有实现代码，实现代码需要在实现接口的类中完成。除此之外，接口也可以定义常量和默认方法（Java 8开始引入）。

在Java中，一个类可以实现一个或多个接口，通过实现接口中的方法来实现接口定义的行为规范。实现接口的类需要提供接口中定义的所有方法的实现，否则会编译错误。

接口的作用主要有以下几点：

* 定义一组统一的行为规范，实现类必须按照规范实现接口中定义的所有方法，使得实现类具有更高的可维护性和可扩展性；

* 接口可以用于实现多继承，一个类可以实现多个接口，从而拥有多种行为规范；

* 接口可以被用来隐藏实现细节，降低系统耦合度。实现类只需关注接口定义的行为规范，而不需要关注接口实现的细节。

### example
以下是一个简单的 Java 接口示例代码：

```csharp
public interface Shape {
    public double area();
    public double perimeter();
}
```

这个示例定义了一个名为 `Shape` 的接口，该接口包含了两个抽象方法 `area()` 和 `perimeter()`。所有实现了 `Shape` 接口的类都必须实现这两个方法。可以将接口看作是一种约定，类通过实现接口来达成某种特定的协议。

下面是一个实现了 `Shape` 接口的 `Rectangle` 类：

```arduino
public class Rectangle implements Shape {
    private double width;
    private double height;

    public Rectangle(double width, double height) {
        this.width = width;
        this.height = height;
    }

    public double area() {
        return width * height;
    }

    public double perimeter() {
        return 2 * (width + height);
    }
}
```

在这个示例中，`Rectangle` 类实现了 `Shape` 接口，并提供了 `area()` 和 `perimeter()` 方法的具体实现。由于 `Rectangle` 实现了 `Shape` 接口，因此可以使用 `Shape` 来声明 `Rectangle` 类型的对象。

接口在 Java 中广泛应用于类的继承和多态等方面，可以使代码更加灵活、可扩展和易于维护。
### 增强for循环
增强for循环（Enhanced For Loop），也叫foreach循环，是Java 5及以上版本引入的一种简化遍历数组和集合的语法结构。

它可以用于数组、List、Set、Map等数据结构的遍历，其语法结构类似于foreach语句。它的语法结构为：
```java
for (Type element : collection) {
    // 循环体
}
```
其中，Type为集合元素的数据类型，element为集合中的元素变量名，collection为被遍历的集合对象。

通过增强for循环，可以简化数组和集合的遍历，使得代码更加简洁和易读。例如，对于数组的遍历，可以使用以下语法：
```java
int[] numbers = {1, 2, 3, 4, 5};
for (int number : numbers) {
    System.out.println(number);
}
```
而对于List的遍历，可以使用以下语法：
```java
List<String> names = Arrays.asList("Alice", "Bob", "Charlie");
for (String name : names) {
    System.out.println(name);
}
```
使用增强for循环，可以避免使用传统的for循环时需要手动维护计数器和下标等变量，从而减少了出错的机会，提高了代码的可读性和可维护性。

### 可变长参数
Java可变长参数是指方法或构造函数中的参数个数不确定，可以接受任意数量的参数。在Java中，可变长参数使用三个点（...）表示，放置在方法或构造函数的参数列表最后一个参数的类型名称后面，例如：
```java
public void printValues(String... values) {
    for (String value : values) {
        System.out.println(value);
    }
}
```

在上面的代码中，printValues方法接受一个或多个String类型的参数，并使用for-each循环遍历每个参数并打印它们的值。

可变长参数的使用有以下几点注意事项：

* 可变长参数必须是方法或构造函数的最后一个参数。

* 可变长参数可以使用任何类型的参数，包括原始数据类型、对象类型、数组类型等。

* 可变长参数在方法或构造函数内部是一个数组类型的参数。

* 如果同时存在多个参数，可变长参数必须在最后一个参数的位置上，否则会编译错误。

*  如果没有传递任何参数，可变长参数的长度为0。

* 可以将一个数组作为可变长参数传递给方法或构造函数。

* 可变长参数可以与其他类型的参数组合使用，例如：  

```java
public void printValues(String prefix, String... values) {
    System.out.print(prefix);
    for (String value : values) {
        System.out.print(value + " ");
    }
    System.out.println();
}
```

在上面的代码中，printValues方法接受一个前缀字符串和一个或多个字符串参数，并将它们一起打印输出。

使用可变长参数可以使方法的定义和调用更加简洁和灵活，尤其是对于参数数量不确定的情况，可以避免定义多个方法的麻烦。需要注意的是，在实际使用中需要谨慎使用可变长参数，以避免参数数量过多导致性能问题。

### 就近原则

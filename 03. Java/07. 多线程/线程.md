# 线程
## 线程的基本概念
线程（Thread）是程序中执行的基本单元，是操作系统能够进行运算调度的最小单位。一个进程可以包含多个线程，它们共享进程的资源（如内存、文件句柄等）并同时执行任务。在Java中，线程可以用来实现并发编程，提高程序执行效率。

Java中的线程可以理解为程序执行流程的一个分支，它与其他线程并发执行。线程共享进程的资源，如堆内存、文件句柄等，但每个线程拥有自己的栈内存，用于存储局部变量和方法调用。
    
## 线程的创建和使用

在Java中，有两种方式创建和使用线程：

a. 继承Thread类：创建一个新类，继承自java.lang.Thread类，并覆盖其run()方法。实例化新类并调用start()方法启动线程。例如：

```java
class MyThread extends Thread {
    @Override
    public void run() {
        // 线程执行的任务
    }
}

public class Main {
    public static void main(String[] args) {
        MyThread myThread = new MyThread();
        myThread.start();
    }
}
```

b. 实现Runnable接口：创建一个新类，实现java.lang.Runnable接口，并实现其run()方法。然后将该类的实例传递给Thread类的构造器，最后调用Thread类实例的start()方法。例如：

```java
class MyRunnable implements Runnable {
    @Override
    public void run() {
        // 线程执行的任务
    }
}

public class Main {
    public static void main(String[] args) {
        MyRunnable myRunnable = new MyRunnable();
        Thread thread = new Thread(myRunnable);
        thread.start();
    }
}
```

3.  线程的生命周期： Java线程的生命周期包括以下几个阶段：新建（New）、就绪（Runnable）、运行（Running）、阻塞（Blocked）、死亡（Terminated）。线程的状态可以通过Thread类的getState()方法获取。
    
4.  线程同步和互斥： 由于多线程共享资源，可能会导致数据不一致或其他问题。为解决这些问题，Java提供了同步和互斥机制，如synchronized关键字、Lock接口等。这些机制可以确保多线程访问共享资源时的顺序性和一致性。
    
5.  线程间通信： Java提供了多种线程间通信方式，如wait()、notify()、notifyAll()方法，以及java.util.concurrent包下的高级同步工具（如Semaphore、CountDownLatch等）。
    

使用线程时，需要注意线程安全问题，并合理使用同步和互斥机制以避免死锁、活锁和资源竞争等问题。

## 死锁
### 概念
Java死锁是指两个或多个线程持有自己的锁，并试图获取对方持有的锁，导致两个线程都无法继续执行，从而形成死锁。死锁是一种常见的多线程编程问题，如果不加以处理，会导致程序无响应或崩溃。

死锁的原因主要有两个：资源互斥和循环等待。
* 资源互斥：多个线程争抢同一资源，例如共享变量、文件等。如果多个线程同时持有这些资源中的一部分，就会导致死锁。
* 循环等待：多个线程之间相互等待对方的锁释放，而导致死锁。

Java死锁的发生通常有四个必要条件：互斥条件、请求与保持条件、不剥夺条件和环路等待条件。互斥条件指某个资源同时只能被一个线程持有，请求与保持条件指线程已经持有了至少一个资源，并请求获取其他资源，不剥夺条件指线程已经获得的资源不能被其他线程强制剥夺，环路等待条件指多个线程之间形成了一个环路，每个线程都在等待下一个线程所持有的资源。

当某个线程进入了某个加锁的方法，其他线程完全可以进入其他未加锁的方法，并且会对当前对象的属性值产生影响。

#### 例子
以下是一个简单的Java死锁示例代码：

```java
public class DeadlockDemo {
    // 创建两个对象作为锁
    private static Object lock1 = new Object();
    private static Object lock2 = new Object();

    public static void main(String[] args) {
        // 创建线程1
        Thread t1 = new Thread(new Runnable() {
            public void run() {
                // 同步锁lock1
                synchronized (lock1) {
                    System.out.println("Thread 1: Holding lock 1...");
                    try {
                        // 使线程1暂停10毫秒，放弃对lock1的占用，等待lock2的释放
                        Thread.sleep(10);
                    } catch (InterruptedException e) {}
                    System.out.println("Thread 1: Waiting for lock 2...");
                    // 获取锁lock2
                    synchronized (lock2) {
                        System.out.println("Thread 1: Holding lock 1 & 2...");
                    }
                }
            }
        });

        // 创建线程2
        Thread t2 = new Thread(new Runnable() {
            public void run() {
                // 同步锁lock2
                synchronized (lock2) {
                    System.out.println("Thread 2: Holding lock 2...");
                    try {
                        // 使线程2暂停10毫秒，放弃对lock2的占用，等待lock1的释放
                        Thread.sleep(10);
                    } catch (InterruptedException e) {}
                    System.out.println("Thread 2: Waiting for lock 1...");
                    // 获取锁lock1
                    synchronized (lock1) {
                        System.out.println("Thread 2: Holding lock 1 & 2...");
                    }
                }
            }
        });

        // 启动线程1和线程2
        t1.start();
        t2.start();
    }
}
```

在这个代码中，我们定义了两个锁对象`lock1`和`lock2`，并且有两个线程`t1`和`t2`分别去获取这两个锁。线程`t1`先获取了`lock1`，然后尝试获取`lock2`，线程`t2`先获取了`lock2`，然后尝试获取`lock1`。由于两个线程在互相等待对方释放锁，导致了死锁的发生。

#### 例子2

```java
public class DeadlockDemo {
    private static Object lock1 = new Object(); // 创建两个对象锁
    private static Object lock2 = new Object();

    public static void main(String[] args) {
        // 创建两个线程，分别调用A方法和B方法
        Thread thread1 = new Thread(new Runnable() {
            @Override
            public void run() {
                A();
            }
        });
        Thread thread2 = new Thread(new Runnable() {
            @Override
            public void run() {
                B();
            }
        });
        thread1.start();
        thread2.start();
    }

    private static void A() {
        synchronized (lock1) { // 获取lock1的锁
            System.out.println("A获得lock1的锁");
            try {
                Thread.sleep(1000); // 睡眠1秒，让线程B有机会获取lock2的锁
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println("A尝试获取lock2的锁");
            synchronized (lock2) { // 尝试获取lock2的锁，但是由于线程B已经持有lock2的锁，所以会一直等待下去，形成死锁
                System.out.println("A获得lock2的锁");
            }
        }
    }

    private static void B() {
        synchronized (lock2) { // 获取lock2的锁
            System.out.println("B获得lock2的锁");
            try {
                Thread.sleep(1000); // 睡眠1秒，让线程A有机会获取lock1的锁
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println("B尝试获取lock1的锁");
            synchronized (lock1) { // 尝试获取lock1的锁，但是由于线程A已经持有lock1的锁，所以会一直等待下去，形成死锁
                System.out.println("B获得lock1的锁");
            }
        }
    }
}
```

### 解决

wait()：使当前线程处于等待（阻塞）状态
notify()：唤醒某个等待中的进程
notify()：唤醒所有等待中的进程
wait()与sleep()的重要区别：
当线程在wait状态下会释放线程锁
当线程在sleep状态下不会释放线程锁

## 生产者-消费者问题
生产者消费者问题是指在多线程编程中，存在生产者线程和消费者线程之间对共享资源的访问和使用。当生产者线程向共享资源添加数据时，消费者线程应该能够从中获取数据并进行处理。这个问题通常会导致一些并发编程的问题，如死锁、饥饿和竞态条件等。

在生产者消费者问题中，生产者和消费者是两个独立的线程。生产者负责生产数据并将其添加到共享资源中，消费者负责从共享资源中获取数据并进行处理。因为生产者和消费者线程是独立的，所以它们在访问和操作共享资源时需要进行同步和互斥。

在同步方面，通常使用线程间通信的方式，如等待和通知机制来进行同步。生产者线程会等待消费者线程处理完当前共享资源中的数据，然后再生产新的数据。当新的数据被生产并添加到共享资源中时，生产者线程会通知消费者线程来处理数据。消费者线程会等待生产者线程添加数据，并在数据可用时被唤醒来处理数据。

在互斥方面，通常使用锁机制来确保只有一个线程可以访问和操作共享资源。例如，在Java中可以使用synchronized关键字或者Lock接口来实现锁机制。生产者和消费者线程都需要获取锁来访问共享资源。当一个线程持有锁时，其他线程需要等待锁被释放才能获取锁并访问共享资源。

需要注意的是，在生产者消费者问题中，如果使用不当，可能会出现死锁和饥饿问题。因此，在编写程序时，应该考虑使用合适的同步机制，避免出现竞态条件，以确保程序能够正确地运行。

```java
package com.java.iweb.day20230407_002;

import java.util.LinkedList;

public class ProducerConsumerExample {

    public static void main(String[] args) {
        // 创建一个共享的队列
        LinkedList<Integer> queue = new LinkedList<>();
        // 创建一个生产者和一个消费者
        Producer producer = new Producer(queue);
        Consumer consumer = new Consumer(queue);
        // 启动生产者和消费者线程
        producer.start();
        consumer.start();
    }

    static class Producer extends Thread {
        private LinkedList<Integer> queue;
        private int maxSize = 5;

        public Producer(LinkedList<Integer> queue) {
            this.queue = queue;
        }

        public void run() {
            while (true) {
                synchronized (queue) {
                    // 如果队列满了，等待消费者消费
                    while (queue.size() == maxSize) {
                        try {
                            System.out.println("Queue is full, waiting for consumer to consume...");
                            queue.wait();
                        } catch (InterruptedException e) {
                            e.printStackTrace();
                        }
                    }
                    // 生产一个随机数并加入队列
                    int num = (int) (Math.random() * 100);
                    queue.add(num);
                    System.out.println("Produced: " + num);
                    // 唤醒消费者线程
                    queue.notify();
                }
                // 模拟生产的时间
                try {
                    Thread.sleep((int) (Math.random() * 100));
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }
    }

    static class Consumer extends Thread {
        private LinkedList<Integer> queue;

        public Consumer(LinkedList<Integer> queue) {
            this.queue = queue;
        }

        public void run() {
            while (true) {
                synchronized (queue) {
                    // 如果队列为空，等待生产者生产
                    while (queue.isEmpty()) {
                        try {
                            System.out.println("Queue is empty, waiting for producer to produce...");
                            queue.wait();
                        } catch (InterruptedException e) {
                            e.printStackTrace();
                        }
                    }
                    // 从队列中取出一个数并消费
                    int num = queue.removeFirst();
                    System.out.println("Consumed: " + num);
                    // 唤醒生产者线程
                    queue.notify();
                }
                // 模拟消费的时间
                try {
                    Thread.sleep((int) (Math.random() * 100));
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }
    }
}
```
以上代码实现了一个生产者消费者问题的示例，使用了Java中的线程、锁、等待、唤醒等多线程相关的概念。在这个示例中，生产者和消费者共享一个队列，当队列为空时，消费者线程等待生产者生产；当队列满时，生产者线程等待消费者消费。这个示例中还模拟了生产和消费的时间，使用了随机数来生成生产的数据，使得示例更加实际。


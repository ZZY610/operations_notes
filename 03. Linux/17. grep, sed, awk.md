# grep, sed, awk

## 1. grep
**Global Regular Expression Print（全局正则表达式打印）**
用于查找文本里符合正则表达式的字符串。

语法：grep [OPTION]... PATTERN [FILE]...

fgrep：不解析正则表达式，快速匹配模式

```bash
# 排除字符集
grep "[^0-9]" file 

# 匹配零次或多次
grep "abc*" file

```
### 拓展正则表达式

grep默认使用BRE基本正则表达式引擎。如果想使用拓展正则表达式，用grep -E 或者egrep

egrep支持匹配重复次数、单词边界、逻辑or、括号分组、转义字符等。
```bash

egrep "[ab]{1,2}" file
egrep "ab?a" file
egrep "pattern1|pattern2" file

# 字符组匹配
egrep "(abc)" file

# 匹配一次或零次
egrep "abc?" file

# 匹配一次或多次
egrep "abc+" file

```

### 参数
grep -v ：查找不匹配模式的行。
grep -n ：显示行号

## 2. sed

`sed`（Stream Editor）是一个强大的文本编辑工具，用于在Linux和Unix系统上进行文本处理。它可以从标准输入或文件中读取文本，并根据指定的编辑命令对文本进行转换、替换、删除等操作。以下是 `sed` 命令的一些常见用法和功能：

1. 替换文本：
   - `sed 's/old_text/new_text/' file`：用 `new_text` 替换文件 `file` 中的第一个匹配的 `old_text`。
   - `sed 's/old_text/new_text/g' file`：用 `new_text` 替换文件 `file` 中的所有匹配的 `old_text`。
   - `sed 's/old_text/new_text/2' file`：只替换文件 `file` 中的第二个匹配的 `old_text`。

2. 删除行：
   - `sed '/pattern/d' file`：删除文件 `file` 中包含 `pattern` 的所有行。

3. 插入和追加文本：
   - `sed '/pattern/i new_line' file`：在文件 `file` 中包含 `pattern` 的行之前插入新行 `new_line`。
   - `sed '/pattern/a new_line' file`：在文件 `file` 中包含 `pattern` 的行之后追加新行 `new_line`。

4. 执行多个编辑操作：
   - `sed -e 's/old_text/new_text/' -e '/pattern/d' file`：依次执行多个编辑操作。

5. 执行正则表达式匹配：
   - `sed '/^pattern/ d' file`：删除以 `pattern` 开头的行。
   - `sed '/pattern$/ d' file`：删除以 `pattern` 结尾的行。
   - 更复杂的正则表达式匹配也可以使用。

6. 保存更改到原始文件：
   - 使用 `-i` 选项，例如：`sed -i 's/old_text/new_text/' file`，将更改保存到原始文件中。

7. 输出结果到标准输出：
   - 如果不指定文件名，`sed` 将结果输出到标准输出，例如：`sed 's/old_text/new_text/'`。

8. 多行操作：
   - `sed` 可以处理多行文本，但默认情况下是逐行操作。可以使用 `N` 命令处理多行。

`sed` 是一个非常强大和灵活的文本处理工具，可以用于批量处理文本文件，自动化编辑任务以及文本转换等各种用途。它使用简洁的命令来执行复杂的文本编辑操作，因此在系统管理、脚本编写和文本处理方面非常有用。

### 举例

```bash
sed -r -i 's/(count=")[^"]*/\11/g' as_fund.xml
```

查找文件中的文本模式并将其替换为新的文本模式。

- `-r`: 这个选项告诉 `sed` 使用扩展的正则表达式语法。扩展的正则表达式语法支持更多的元字符和模式匹配功能。

- `-i`: 这个选项表示直接在原始文件上进行编辑，而不是将结果输出到标准输出。也就是说，它将在原始文件上进行替换操作。

- `'s/(count=")[^"]*/\11/g'`: 这是 `sed` 的替换命令，它使用正则表达式模式匹配并替换文本。
   - `(count=")`: 这是一个捕获组，用于匹配以 `count="` 开始的文本。
   - `[^"]*`: 这是一个字符类，匹配任何不包含双引号的字符。
   - `\1`: 这是替换的部分，将匹配的文本替换为 `count="1"`，其中 `\1` 引用了捕获组中的内容。
   - `g`: 这个标志表示在每一行中进行全局替换，而不仅仅是第一次匹配。

综合起来，这个命令的作用是在文件 `as_fund.xml` 中查找所有以 `count="` 开头的文本，并将它们替换为 `count="1"`，从而将所有的 `count` 属性的值都设置为 `1`。

例如，如果原始文件包含如下内容：

```xml
<item count="3">...</item>
<item count="5">...</item>
```

运行上述命令后，文件将被修改为：

```xml
<item count="1">...</item>
<item count="1">...</item>
```

请注意，由于 `-i` 选项，这个替换是直接在文件中进行的，所以要小心操作，确保备份文件或了解修改的影响。

在这个 `sed` 命令中，`\1` 表示一个反向引用，用于引用正则表达式模式中的捕获组内容。具体解释如下：

- `(` 和 `)`：在正则表达式中，括号 `(` 和 `)` 用于创建捕获组，以便捕获匹配的文本。

- `count="`：这部分是正则表达式模式，用于匹配包含 `count="` 的文本。

- `[^"]*`：这是正则表达式模式的一部分，用于匹配任意数量的非双引号字符。

当正则表达式模式中包含捕获组时，`sed` 可以使用 `\1`、`\2`、`\3` 等来引用捕获组的内容。在这个命令中，`\1` 引用了第一个捕获组，也就是 `(count=")` 匹配到的内容。

具体到这个命令的操作，它将匹配到的文本中的 `count="` 替换为 `\1`，也就是保留了原始的 `count="`，这种操作通常用于在正则表达式替换中保留部分原始文本，并只替换其中的一部分。

## 3. awk


`awk` 是一种文本处理工具，取名于三位创始人的姓名首字符。常用于从文本文件中提取数据、格式化输出、进行计算等操作。

它以逐行方式读取输入文件，并根据用户定义的模式和动作进行处理。

`awk` 的基本语法结构为：

```shell
awk 'pattern { action }' file

awk [选项参数] 'script' var=value file(s)
或
awk [选项参数] -f scriptfile var=value file(s)
```

其中，`pattern` 是用于匹配输入行的条件，`action` 是在匹配到的行上执行的操作，`file` 是要处理的输入文件名。

`awk` 的工作原理如下：
1. 逐行读取输入文件。
2. 对于每一行，依次检查所有定义的模式（`pattern`）。
3. 如果某个模式匹配当前行，执行相应的操作（`action`）。
4. 处理完所有模式后，处理下一行。

可以使用内置变量、函数和操作符来实现更复杂的文本处理任务。

常用的 `awk` 内置变量：
- `NR`：当前行的行号。
- `NF`：当前行的字段数。
- `$0`：当前行的完整内容。
- `$1, $2, ...`：当前行的第 1, 2, ... 个字段。

常用的 `awk` 内置函数：
- `print`：打印指定的内容。
- `getline`：读取下一行。
- `split`：将字符串分割成数组。
- `length`：计算字符串或数组的长度。
- `substr`：提取字符串的子串。
# 00. 永恒的矛盾
出现问题 -> 解决问题 -> 新的问题 -> 再次解决

1. 内存永远不够用。  
2. CPU 永远不够强。  
3. 人永远嫌慢。  

全部操作系统概念，都是为了解决这三个问题。

---

## 0. 史前时代 - 只有硬件，没有OS

*   **需求**：让计算机执行计算任务（例如，计算弹道导弹轨迹）。
*   **硬件状态**：巨大的庞然大物（如ENIAC），通过物理线路（插板）或机械开关编程。没有存储程序的概念。
*   **工作方式**：**“人肉”操作系统**。
    1.  程序员提前预约一大段机时。
    2.  走到机器前，通过手动拨动开关或插入插板，将程序和所需数据加载到内存中。
    3.  按下按钮，启动程序运行。
    4.  程序运行期间，整个计算机的所有资源（CPU、内存、外设）都被它独占。
    5.  程序运行结束（或崩溃），输出结果（可能是打印在纸上或灯盘显示）。
*   **遇到的巨大问题**：
    1.  **极低的CPU利用率**：这是最核心的矛盾。在程序进行I/O操作（如读纸带、打印输出）时，速度极快的CPU就在那**空转**，等待速度慢如蜗牛的外设。这就是所谓的“人闲着机器等”。
    2.  **准备时间过长**：手动 setup 的时间可能比程序运行时间还长。
    3.  **毫无公平性**：一个程序 bug 导致死循环，机器就彻底卡死，只能强行断电。
| 名称 | 概念 | 为了解决什么问题？ | 实现方法 | 又引入了什么新的问题？ |
| :--- | :--- | :--- | :--- | :--- |
| **人机操作** | 程序员直接通过物理方式（拨动开关、插拔线路）操作计算机硬件。 | 让计算机执行计算任务。 | 人工手动操作。 | **极低的CPU利用率**：准备时间远超计算时间。**机器独占**：一次只能一人使用。 |
{.small}

---

## 1. 批处理系统 - 解决CPU空闲问题

*   **新需求**：**减少CPU空闲时间**，提高吞吐量（单位时间内完成的工作量）。
*   **解决方案**：**批处理** 概念的出现。
    1.  **外围机与磁带**：程序员将程序（作业）写在纸带上，由一台专门的、便宜的**外围计算机**（如IBM 1401）将这些纸带数据转录到高速磁带上。
    2.  **监控程序**：主计算机（如IBM 7094）上运行一个常驻内存的、简单的**监控程序**。这是操作系统的**雏形**。
    3.  **自动切换**：监控程序从磁带上自动读取第一个作业，运行它。作业结束后，监控程序**自动地**清理现场，然后从磁带上加载下一个作业并运行。
*   **带来的好处**：
    *   **减少了人力干预**：准备时间从分钟级缩短到秒级。
    *   **提高了吞吐量**：作业间的切换由机器完成，速度更快。
*   **产生的新问题**：
    1.  **CPU和I/O设备速度不匹配**的核心矛盾依然存在。CPU在作业进行I/O时依然要等待。
    2.  **交互性为零**：程序员提交作业后，就像抛漂流瓶，需要几小时甚至第二天才能知道结果（成功/编译错误/运行错误），**调试效率极低**。

| 名称 | 概念 | 为了解决什么问题？ | 实现方法 | 又引入了什么新的问题？ |
| :--- | :--- | :--- | :--- | :--- |
| **监控程序** <br> (1950s) | 常驻内存的一段基础软件，是OS的雏形。 | 减少作业间的人工干预，提高吞吐量。 | 使用外围机将作业录入磁带，监控程序从磁带自动加载和运行作业。 | **缺乏交互**：用户提交作业后无法干预。**CPU与I/O速度矛盾**：CPU在作业进行I/O时依然空闲。 |
| **作业队列** <br> (1950s) | 等待处理的作业的有序集合。 | 自动化作业的顺序执行。 | 在磁带或磁盘上按顺序组织作业。 |  |
{.small}

---

## 2. 多道程序系统 - 解决CPU等待I/O问题

*   **新需求**：**彻底压榨CPU，让它一刻也别停**。
*   **解决方案**：**多道程序设计**。
    *   **核心思想**：在内存中**同时存放多道程序**。当当前运行的程序需要发起I/O操作时，CPU不是傻等，而是**立刻切换到内存中另一个就绪的程序去执行**。
    *   **所需技术支持**：
        1.  **硬件中断和DMA**：I/O设备完成工作后，通过**中断**通知CPU。DMA（直接内存访问）技术让I/O设备可以直接与内存交换数据，无需CPU亲自一个个字节搬运，进一步解放了CPU。
        2.  **内存保护**：必须防止一道程序出错而覆盖掉另一道程序甚至监控程序的内存。这催生了**基址寄存器和界限寄存器**等硬件机制。
*   **带来的好处**：
    *   **CPU利用率飙升**：CPU几乎总是在工作，系统吞吐量达到极大值。
*   **产生的新问题**：
    1.  **资源管理的复杂性爆炸**：内存如何分配和保护？多个程序竞争CPU，谁先谁后？（**CPU调度算法**诞生）。它们竞争有限的I/O设备怎么办？（**死锁**问题浮出水面）。
    2.  **交互性依然为零**：这依然是批处理模式，用户无法与运行中的程序交互。

| 名称 | 概念详解 | 为了解决什么问题？ | 实现方法 / 原理 | 又引入了什么新的问题？ |
| :--- | :--- | :--- | :--- | :--- |
| **内核态 vs. 用户态**<br>(CPU特权级别) | CPU运行时的两种不同权限级别。<br>**内核态**：运行操作系统内核代码。CPU可以执行指令集中的**所有指令**，包括操作硬件的**特权指令**（如操作I/O设备、开关中断、修改内存管理寄存器等）。<br>**用户态**：运行普通应用程序代码。CPU只能执行指令集的一个**子集**，执行特权指令会引发异常，被操作系统接管。 | **安全与保护**：防止用户程序有意或无意地执行危险操作，破坏操作系统或其他程序，从而保证系统的稳定性和安全性。这是多道程序共存的前提。 | CPU硬件提供一个**模式位**（如x86的CPL）来标识当前状态。执行某些关键指令前，硬件会检查该模式位。从用户态进入内核态的**唯一途径**是通过**中断、异常或陷阱**。 | **开销**：在用户态和内核态之间切换（**上下文切换**的一部分）需要时间开销。<br>**设计复杂性**：操作系统必须精心设计，确保所有需要特权的操作都提供了相应的接口（系统调用）。 |
| **中断** | 一个来自硬件或软件的**异步信号**，通知CPU需要立即处理某个事件。CPU会暂停当前指令流，保存现场，转去执行特定的处理程序，完成后恢复原现场继续执行。 | **1. 提高效率**：使CPU不必轮询等待慢速I/O设备完成工作。<br>**2. 实现并发**：使操作系统能及时响应外部事件，夺回控制权进行调度。 | **硬件中断**：由外部设备（时钟、磁盘、网卡）通过中断控制器（如8259A）发出中断请求(IRQ)，CPU收到后通过**中断向量表**跳转到对应的**中断服务程序**。<br>**异常**：由CPU内部执行指令时触发（如除零、页错误、访问非法地址），是**同步**的。<br>**陷阱**：程序**主动**发起的（如执行`int 0x80`或`syscall`指令），目的是请求操作系统服务。 | **延迟**：中断处理会引入不可预测的执行延迟。<br> **并发控制**：中断处理程序本身也可能被更高优先级的中断打断，需要小心处理数据共享问题。 |
| **系统调用** | 操作系统封装好的一系列接口，作为用户程序请求内核服务的**唯一安全通道**。是用户程序与操作系统之间的“边界”。 | **如何让用户态程序安全地使用内核功能？** 用户程序无法直接操作硬件，必须通过一个受控的“大门”向内核申请，由内核代其执行。 | 1. 软件触发一个**陷阱**（软中断），并传递一个**系统调用号**来标识所需服务。<br>2. CPU切换到内核态，根据系统调用号在**系统调用表**中查找对应的服务例程地址。<br>3. 内核执行服务例程，验证参数安全性，完成操作。<br>4. 返回结果，切换回用户态。 | **性能开销**：相比简单的函数调用，系统调用需要完整的上下文切换，开销更大。<br> **接口设计**：需要设计稳定、清晰、高效的API。 |
| **DMA**<br>(直接内存访问) | 一个独立的**硬件控制器**，可以接管CPU对总线的控制权，在外设和主内存之间直接进行数据搬运。 | **彻底解决PIO的弊端**：将CPU从低速的I/O数据搬运工作中彻底解放出来，使其在I/O过程中能真正执行其他计算任务，极大提升系统并行度和效率。 | 1. CPU对DMA控制器进行编程：设置**源地址**（设备地址）、**目标地址**（内存地址）、**数据长度**。<br>2. CPU启动DMA传输后，即可去执行其他任务。<br>3. DMA控制器独立完成整个数据块的传输。<br>4. 传输结束后，DMA控制器向CPU发送一个**中断**通知。 | **缓存一致性**：DMA直接操作内存，可能绕过CPU的缓存，导致缓存中的数据与内存不一致，需要硬件机制（如总线监视）或软件刷缓存来保证一致性。<br> **硬件成本**：需要额外的DMA控制器芯片。 |
| **内存保护** | 防止一个程序访问或修改不属于它的内存区域（如操作系统或其他用户程序的数据）。 | **多道程序共存的基础**：保证在内存中同时存在的多个程序相互隔离，互不干扰。一个程序的错误（如野指针）不会导致整个系统崩溃。 | **基址寄存器与界限寄存器**：<br>CPU硬件提供一对寄存器。**基址寄存器**存放当前程序在物理内存的起始地址，**界限寄存器**存放其长度。程序产生的所有内存地址都是**逻辑地址**，CPU硬件会将其与基址相加得到**物理地址**，并检查是否越界。越界则触发异常。 | **碎片化**：多个程序来回加载和换出，会在内存中产生**外部碎片**，降低内存利用率。<br> ** relocation **：程序每次加载到物理内存的地址不能固定，需要硬件支持地址转换。 |
| **时钟** | 一个按固定频率产生中断的硬件计时器。 | **1. 防止垄断**：操作系统通过**时钟中断**定期夺回CPU控制权，防止一个程序死循环或拒绝释放CPU。<br>**2. 计时**：为系统提供时间概念，用于时间片轮转、统计、超时判断等。 | 时钟硬件每隔一个固定时间（如10ms）就产生一次中断。CPU响应后，操作系统获得控制权，可以决定是继续当前任务还是切换到另一个任务。 | **粒度与开销**：时间片设置得太短，上下文切换开销占比过大；设置得太长，系统响应性变差。 |
| **SPOOLing**<br>(Simultaneous Peripheral Operations On-Line) | 一种将独占设备改造成共享设备的**虚拟化技术**，通常用于管理低速的I/O设备（如打印机）。 | **解决打印机等独占设备的共享问题**：多个用户都可以发出打印请求，而不会因为打印机被占用而等待。 | 在磁盘上开辟一块区域作为**打印队列**。用户的打印输出先被快速写入磁盘队列，然后由后台的**守护进程**（Daemon）逐个从队列中取出，真正发送给打印机。 | **磁盘空间管理**：需要管理SPOOLing目录的空间。<br> **队列调度**：需要决定打印任务的优先级（先来先服务？紧急任务优先？）。 |
{.small}

---

## 3. 分时系统 - 解决交互性问题

*   **新需求**：**让用户能够与计算机“对话”**，进行编程、调试等交互式工作。
*   **解决方案**：**分时技术**。
    *   **核心思想**：将CPU的时间划分成极短的**时间片**（比如几十毫秒）。操作系统以很高的频率在多个用户任务之间进行**切换**。由于切换速度极快，每个用户都感觉自己在独占整个计算机。
    *   **哲学飞跃**：多道程序是为了**优化系统效率**（吞吐量），而分时系统是为了**优化用户体验**（响应时间）。
*   **带来的好处**：
    *   **交互性诞生**：Unix、Multics等系统诞生，命令行界面成为程序员的天堂。用户可以即时输入命令并得到结果。
    *   **促进了软件开发**：交互式调试成为可能，软件开发效率大幅提升。
*   **产生的新问题**：
    1.  **对性能的要求极高**：频繁的上下文切换本身是有开销的。如果用户太多或时间片太短，系统可能把大部分时间都花在“切换”上，而不是“干活”上。
    2.  **数据安全和隐私**：多个用户的程序在同一台机器上运行，必须严格隔离。**权限管理**和**文件系统安全**变得至关重要。

| 名称与诞生背景 | 概念 | 为了解决什么问题？ | 实现方法 / 原理 | 又引入了什么新的问题？ |
| :--- | :--- | :--- | :--- | :--- |
| **分时技术** <br> (CTSS, 1961; Multics, 1960s) | 将CPU时间划分为极短的时间片，轮流为多个交互式用户服务。 | 让每个用户感觉自己独占计算机，**实现交互式操作**。 | 基于**时钟中断**进行强制调度。 | **性能开销**：频繁上下文切换消耗资源。**公平性**：如何分配时间片？**安全性**：多用户权限管理。 |
| **进程 (Process)**<br>（概念在MIT的Multics和贝尔实验室的UNIX系统中成熟定型） | **一个正在执行的程序的实例**。它是系统进行**资源分配（CPU、内存）和调度（CPU时间）的独立基本单位**。它不仅仅是程序的代码，还包括当前执行状态（寄存器、程序计数器）、栈、堆、打开的文件等。 | **1. 封装与隔离**：为每个运行中的程序提供一个独立的、受保护的执行环境，使其在多任务系统中互不干扰。<br>**2. 调度基础**：为CPU调度提供一个清晰的实体。操作系统调度的是进程，而不是模糊的“作业”。 | **进程控制块 (PCB)**：内核中为每个进程维护的一个数据结构，它是进程存在的唯一标志。PCB包含：<br>- **进程ID**：唯一标识符。<br>- **进程状态**：运行、就绪、阻塞等。<br>- **程序计数器**：下一条要执行的指令地址。<br>- **CPU寄存器**：当进程被切换时，它们的值被保存到这里。<br>- **内存管理信息**：基址/界限寄存器或页表指针。<br>- **记账信息**：CPU使用时间、时间片等。<br>- **I/O状态信息**：该进程打开的文件列表、分配的I/O设备。 | **1. 管理开销**：创建、销毁、切换进程需要操作PCB，占用CPU时间。<br>**2. 进程间通信**：隔离的进程如何安全、高效地交换数据？(IPC问题)<br>**3. 进程同步**：多个进程竞争共享资源时，如何避免混乱？ |
| **进程状态与切换**<br>（与进程概念一同发展） | 描述进程在其生命周期中所处的状态及其转换规则。经典三状态模型：<br>- **运行**：进程正在CPU上执行。<br>- **就绪**：进程已准备好，可运行，正等待CPU。<br>- **阻塞**：进程正在等待某个事件完成（如I/O操作），即使分配CPU也无法运行。 | **精确描述和管理进程的行为**，为CPU调度提供依据。 | 状态转换由**事件**触发：<br>- **运行 -> 阻塞**：进程发起I/O请求等。<br>- **运行 -> 就绪**：时间片用完或被更高优先级进程抢占。<br>- **阻塞 -> 就绪**：等待的事件发生（如I/O完成）。<br>- **就绪 -> 运行**：被调度器选中。 | **状态队列管理**：操作系统需要维护**就绪队列**、**设备等待队列**等多个队列来管理处于不同状态的进程。 |
| **时间片轮转调度**<br>（分时系统的核心调度算法） | 一种**抢占式**的CPU调度算法。每个进程被分配一个固定的、很短的时间单元，称为**时间片**。进程在CPU上运行一个时间片后，如果还未结束，会被强制剥夺CPU并放回就绪队列末尾，等待下一轮调度。 | **保证公平性和响应性**：让每个交互式用户都能在可接受的时间内（通常<1秒）得到系统的响应，产生“独占计算机”的错觉。 | 基于**时钟中断**实现。时钟中断发生时，调度器检查当前进程已运行的时间。如果达到或超过时间片，就执行**上下文切换**，从就绪队列头部选择下一个进程运行。 | **1. 时间片大小选择**：时间片太短，上下文切换开销占比过大；时间片太长，响应性变差（像批处理）。<br>**2. 平均等待时间长**：对于长时间运行的批处理作业不公平。 |
| **上下文切换**<br>（进程调度的核心操作） | 将CPU从一个进程切换到另一个进程执行的过程。这个过程需要**保存旧进程的状态**并**加载新进程的状态**。 | **实现多进程在单个CPU上并发执行的 illusion**。 | 1. 接收到切换信号（时钟中断、系统调用）。<br>2. 保存旧进程的**上下文**（所有CPU寄存器的值）到其PCB中。<br>3. 将新进程的上下文从其PCB加载到CPU寄存器中。<br>4. 更新内存管理单元（MMU）等硬件状态（如页表寄存器）。<br>5. 跳转到新进程上次被中断的代码位置继续执行。 | **纯粹的开销**：上下文切换期间，CPU没有执行任何用户有用的工作。切换速度是衡量操作系统性能的关键指标。 |
| **进程间通信**<br>（多进程必然带来的需求） | 允许进程之间相互交换数据和信息的技术。 | **协作**：多个进程可能需要协作完成一个大任务（如管道：`ls | grep "txt"`）。<br>**信息传递**：一个进程需要将数据发送给另一个进程。 | **1. 共享内存**：进程映射同一块物理内存区域。速度最快，但需要**同步机制**来避免冲突。<br>**2. 消息传递**：通过操作系统内核提供的服务（如消息队列）发送和接收消息。 slower but simpler。 | **1. 同步问题**：共享内存需要额外机制防止数据竞争。<br>**2. 性能开销**：消息传递涉及内核介入，需要数据拷贝。<br>**3. 死锁**：两个进程相互等待对方持有的资源。 |
| **交互式Shell**<br>（如Unix的Bourne Shell） | 一个**特殊的用户进程**，它是用户与操作系统内核之间的**命令解释器**。它提供了一个命令行界面，读取用户命令，创建新的进程来执行这些命令，并管理输入/输出重定向和管道。 | **为用户提供一个统一、强大、可编程的方式来与系统交互**，而不仅仅是运行单个程序。 | 1. 显示提示符，等待用户输入。<br>2. 读取命令字符串，进行解析。<br>3. **调用`fork()`系统调用**，创建一个子进程（shell的副本）。<br>4. 在子进程中**调用`exec()`系统调用**，加载并执行目标程序，替换自身。<br>5. Shell父进程通常调用`wait()`，等待子进程结束。 | **进程创建开销**：执行任何命令都需要先创建新进程。 |
{.small}



---

## 4. 个人操作系统 - 解决个人计算需求

*   **新需求**：**让计算机成为个人工具**，便宜、易用、专属于一个人。
*   **硬件基础**：大规模集成电路（LSI）和微处理器（CPU on a chip）的发展，使个人电脑（PC）成为可能。
*   **解决方案**：**为单用户设计的操作系统**，如MS-DOS、早期的Mac OS。
    *   **哲学回溯**：某种程度上回到了“单用户独占”模式，但保留了多道、分时的先进功能（如能同时运行多个程序）。
    *   **重点转移**：从追求吞吐量和多用户安全，转向**图形用户界面**、**易用性**和**丰富的应用程序生态**。
*   **产生的新问题**：
    1.  **稳定性挑战**：一个流氓应用程序就可能让整个系统崩溃，因为最初缺乏强大的内存保护（例如MS-DOS）。
    2.  **资源冲突**：声卡、显卡等硬件设备的配置异常复杂（跳线、IRQ冲突），即插即用成为迫切需求。
| 名称 | 概念 | 为了解决什么问题？ | 实现方法 | 又引入了什么新的问题？ |
| :--- | :--- | :--- | :--- | :--- |
| **图形用户界面(GUI)** <br> (Xerox Alto, 1973; Macintosh, 1984) | 使用窗口、图标、菜单和指针(WIMP)与计算机交互。 | 让计算机**易学易用**，降低使用门槛，推向大众市场。 | 在操作系统中集成图形显示、事件处理（鼠标、键盘）的核心服务。 | **资源消耗大**：需要更快的CPU、更大的内存和显存。**硬件兼容性**：需要支持各种显卡、声卡等。 |
| **文件格式/应用程序** | 操作系统生态的重要组成部分。 | 满足个人用户办公、娱乐等多样化需求。 | 操作系统提供API供应用程序调用，应用程序处理特定格式的文件。 | **稳定性**：一个应用程序崩溃可能导致整个系统崩溃（早期系统如Win9x）。 |
{.small}

---

## 5. 现代操作系统内核 - 解决稳定性和安全性

*   **新需求**：**系统必须稳定、安全、强大**。
*   **解决方案**：吸收大型机操作系统的设计精华，并引入新理念。
    1.  **微内核 vs 宏内核**：关于如何设计内核的哲学争论。宏内核（Linux）将大量功能放入内核，性能高；微内核（MacOS的一部分）只保留最核心功能，将其他作为服务运行，稳定性更好。
    2.  **硬件的内存管理单元**：提供了**虚拟内存**功能。每个进程都有自己独立的、完整的虚拟地址空间，实现了进程间完美的隔离。一个进程崩溃绝不会影响他人。
    3.  **强大的权限模型**：如Unix的“一切皆文件”和用户/组/权限位模型，Windows的ACL访问控制列表。
    4.  **标准化驱动模型**：如Windows的WDM，解决了硬件配置的噩梦。
| 名称 | 概念 | 为了解决什么问题？ | 实现方法 | 又引入了什么新的问题？ |
| :--- | :--- | :--- | :--- | :--- |
| **虚拟内存** <br> (成熟于1980s) | 为每个进程提供统一的、隔离的虚拟地址空间。 | 1. **内存不够用**：运行比物理内存大的程序。<br>2. **安全**：进程隔离。<br>3. **简化编程**：程序员使用连续逻辑地址。 | **按需分页** + **MMU（内存管理单元）** 硬件。将 rarely used 的页换出到磁盘。 | **性能开销**：地址转换、缺页中断。**复杂性**：页面置换算法设计（如LRU）。 |
| **权限模型** <br> (UNIX, 1970s) | 系统资源访问控制规则（如用户、组、文件权限位）。 | **多用户系统中的安全与隐私**：防止用户越权访问数据或破坏系统。 | 为每个文件和进程标记其所有者及权限。系统调用执行前进行权限检查。 | **管理复杂性**：配置和管理用户权限。 |
| **微内核架构** <br> (概念: 1980s) | 将操作系统核心功能最小化，其他服务作为用户态进程运行。 | **提高可靠性、安全性和可维护性**：驱动等服务崩溃不会导致整个内核崩溃。 | 内核仅提供进程间通信(IPC)、地址空间等最基本服务。文件系统、驱动等作为服务运行。 | **性能瓶颈**：频繁的进程间通信(IPC)可能带来性能损失。（与**宏内核**的哲学之争） |
{.small}

---

## 6. 网络操作系统与分布式系统 - 解决互联与全球化

*   **新需求**：**计算机之间要通信**。
*   **解决方案**：**将网络功能深度融入操作系统**。
    *   **协议栈**：在操作系统中内置TCP/IP协议栈。
    *   **套接字**：提供**Socket API**，让网络编程就像读写文件一样方便。
    *   **分布式操作系统**（更前沿）：让多台计算机像一台计算机一样工作，处理**一致性**、**容错**等更复杂的问题。

| 名称 | 概念 | 为了解决什么问题？ | 实现方法 | 又引入了什么新的问题？ |
| :--- | :--- | :--- | :--- | :--- |
| **TCP/IP协议栈** <br> (集成于4.2BSD, 1983) | 互联网的通信协议族，内置于操作系统内核。 | 让计算机能够接入全球网络，相互通信。 | 在内核中实现IP、TCP、UDP等协议的处理。 | **网络安全**：防火墙、病毒、黑客攻击。 |
| **Socket API** <br> (4.2BSD, 1983) | 网络编程的通用接口，使网络操作像文件操作一样简单。 | 为应用程序提供统一、简便的网络访问能力。 | 提供一组系统调用（如`socket`, `bind`, `connect`, `send`, `recv`）。 |  |
| **分布式操作系统** | 管理多台计算机，使其像一个单一系统一样工作。 | 整合资源，提供更高的性能、可靠性和可用性。 | 中间件、分布式文件系统（如NFS）、分布式计算模型。 | **一致性**：如何保证多副本数据的一致性？**容错**：部分机器故障时如何维持服务？**复杂性**：极高。 |
{.small}

---

## 总结：一部永恒的“解决问题”的历史

操作系统的发展史，就是一部不断解决旧问题，同时发现新问题的历史。其核心驱动力始终是：

1.  **提高效率**：从批处理到多道，到分时。
2.  **降低复杂度**：通过抽象（进程、文件、套接字）向用户和程序员隐藏硬件的丑陋细节。
3.  **增强功能**：从计算到交互，到图形，到网络。
4.  **保证安全与稳定**：通过隔离、权限和虚拟化。

每一个解决方案都建立在硬件技术的进步之上，同时也对硬件提出了新的要求（中断、MMU、多核）。最终，操作系统成为了我们在**硬件裸机**之上构建的一个更为强大、友好、安全的**虚拟计算机**，它管理的不仅仅是资源，更是复杂性本身。

1 内存不够 → “分段”出世  
时间：1950 年代末  
机器：IBM 709  
问题：物理内存只有 32 KB，但程序编译出来 40 KB，连装都装不下。  
初代办法：把程序切成几段（代码段、数据段），**只把当前用到的段塞进内存**，别的留在磁带——这就是**分段（Segmentation）**。  
新问题：段大小不固定，内存很快出现**外部碎片**（大程序来了，好多小空洞拼不起来）。

------------------------------------------------
2 碎片太多 → “分页”登场  
时间：1960 年代初  
机器：Atlas（曼彻斯特大学）  
新招：把内存固定切成 4 KB 的小块，叫**页框（page frame）**；程序也切成 4 KB 的**页（page）**。  
好处：碎片从“大小不一”变成“最多浪费 4 KB”，**内部碎片**可接受。  
但 CPU 怎么知道“虚拟页 0 → 物理页 5”？——**页表**诞生，硬件里加了**MMU**，每次地址自动查表。  
新问题：页表太大。32 位地址空间 + 4 KB 页 → 1 M 个页表项，4 MB 内存没了，**“页表自己吃光内存”**。

------------------------------------------------
3 页表太大 → 多级、倒排、TLB 三连击  
① 多级页表（1980s，BSD）：把单张 4 MB 的大表拆成 1024 张 4 KB 小表，**用不到的就干脆不分配**。  
② 倒排页表（IBM Power）：不按“虚拟页→物理页”，反过来“物理页→虚拟页”，**一张表管整机**，内存省但查表慢。  
③ TLB（Translation Lookaside Buffer）：硬件缓存最近用过的映射，**把每次查表从“访存一次”降到“0 次”**。  
新问题：进程切换时要刷新 TLB，**切进程变贵**。

------------------------------------------------
4 切进程太贵 → 线程 + 地址空间共享  
时间：1990s  
场景：Web 服务器每来一个连接就 fork()，TLB 刷新 + 拷贝页表，**慢到不能忍**。  
新招：**线程（Thread）**，只新建 task_struct，**共享同一套页表**，切换时 TLB 不用刷。  
副作用：共享地址空间 → 一个线程野指针弄死全场，**调试地狱**。

------------------------------------------------
5 CPU 不够 → 调度器连续剧  
① 批处理时代（50-60 年代）：手工把磁带塞进机器，**串行执行**，利用率 10% → 受不了。  
② 多道程序（Multiprogramming，1964 OS/360）：内存同时放 N 个程序，**A 等 I/O 就换 B 上**，利用率提到 50%。  
③ 分时系统（CTSS, 1961）：给每个程序定**“时间片”**，人坐在终端前错觉“独占机器”，**交互式体验**诞生。  
④ 实时/多媒体（90s）：时间片固定导致音顿卡，**优先级 + 抢占式调度**（Linux O(1)、CFS、RT 调度器）。  
新问题：多核 CPU 出现，**全局队列锁竞争** → 每核维护自个的**运行队列（sched_domain）**。

------------------------------------------------
6 内存还是不够 → 换页 + 交换分区  
场景：32 位 Windows 95 开 3 个 IE 就内存报警。  
新招：把**不常用的页踢到磁盘**，叫**换出（swap out）**，用到再**换入（swap in）**。  
新问题：磁盘比内存慢 10 万倍，**一换就卡** → 算法必须“猜”谁最久不会被用。  
算法演进：  
FIFO → Belady 异常 → 最优（OPT，神仙算法，当标尺） → LRU（用过去预测未来） → 时钟（Clock，近似 LRU 但省内存） → Linux 二次机会 → 近年机器学习预测。

------------------------------------------------
7 磁盘太慢 → 缓冲区 → 页缓存统一  
早期：每个文件系统自己搞**磁盘缓冲区**。  
发现：反正都是 4 KB 块，**干脆和内存页缓存合并**，一块内存既当“页”又当“缓冲区”——**page cache**诞生。  
副作用：malloc() 得到的匿名页和 read() 读进的文件页**抢内存**，需要**回收算法**（LRU 变种 + 脏页回写）。

------------------------------------------------
8 设备太慢 → 中断 → DMA → 零拷贝  
① 轮询（polling）：CPU 死等键盘，**100% 空转**。  
② 中断（1954，UNIVAC）：外设就绪就**拉一根电线**触发 CPU，CPU 放下当前任务跳去 ISR，**空转问题解决**。  
新问题：频繁中断把 CPU 打断成碎片。  
③ DMA（1960s）：硬件自己搬数据，**CPU 只收一个“搬完”中断**。  
④ 零拷贝（2000s）：网卡直接发**页缓存里的数据**，**不用先 copy_to_user 再 copy_from_user**，sendfile() 系统调用省两次内存拷贝。

------------------------------------------------
9 指针野 → 保护 → 分段 + 分页 + 特权级  
早期：物理地址裸跑，**一个指针可以改操作系统**。  
80286 起：  
- 分段 + 分页双层保护；  
- CPU 增加**特权级 ring 0~3**，用户指针想写内核页 → MMU 直接抛**段错误/页错误**。  
副作用：ring 0 太强大，**驱动写错就蓝屏** → 微内核/用户态驱动（FUSE、用户态网卡驱动）。

------------------------------------------------
10 人永远嫌慢 → 并行 → 多核 → 缓存一致性  
2005 年后：单核主频撞墙，**转向多核**。  
新问题：  
- 两个 CPU 同时改同一缓存行 → **缓存不一致** → 需要**MESI 协议**（Modified-Exclusive-Shared-Invalid）。  
- 调度器要把**进程尽量固定在同一核**，避免**迁移导致缓存失效**（CPU affinity）。  
再往后：NUMA（每核有本地内存）、异构（big.LITTLE）、chiplet……故事还在继续。

------------------------------------------------
把这条“连环套”背下来，你就拥有了“时间轴”视角：  
**任何新概念，先问三句话——**  
1. 它之前出了啥问题？  
2. 它具体怎么续命？  
3. 续命后又埋了哪些新雷？  

带着这三句话去看任何操作系统教材，你会发现**“调度”“分页”“中断”“堆栈”**不再是散点，而是同一部“人类给计算机续命史”的不同章节。
# 05. 计算机启动流程

## 00. 总览



1. **通电与自检**  
   - **电源通电**：按下电源按钮，计算机获得电力。  
   - **CPU自检（POST）**：CPU会检查硬件（内存、键盘、显卡等）是否正常工作。  
   - 核心概念：电源、CPU、POST

2. **固件启动**  
   - **BIOS/UEFI启动**：CPU加载存储在主板上的固件代码。  
   - **BIOS**（老式固件）或 **UEFI**（现代固件）会初始化硬件，并为加载操作系统做准备。  
   - 核心概念：BIOS、UEFI、固件

3. **读取启动盘**  
   - 固件检查所有启动设备（硬盘、光驱、USB 等），寻找包含操作系统启动代码的区域。  
   - 在传统系统中，这个区域是硬盘的第一个扇区，称为 **MBR（主引导记录）**；在 UEFI 系统中，则使用 **EFI 分区**。  
   - 核心概念：扇区、MBR、EFI

4. **引导加载程序（Bootloader）**  
   - 固件加载并执行 Bootloader，它是一个小程序，负责进一步加载操作系统。  
   - Bootloader 会从磁盘中读取操作系统的内核代码到内存，并把控制权转交给内核。  
   - 核心概念：Bootloader、内核加载

5. **操作系统内核启动**  
   - 内核开始运行，进行硬件初始化、内存管理、设备驱动加载和中断设置。  
   - 内核还会创建必要的数据结构，管理进程和任务调度。  
   - 核心概念：内核、内存管理、设备驱动、中断、任务调度

6. **启动系统服务与用户界面**  
   - 内核启动后，会加载系统服务（守护进程）和用户界面（图形界面或命令行界面）。  
   - 用户可以登录，开始使用操作系统。  
   - 核心概念：系统服务、用户界面

这就是计算机从通电到完全启动的全过程，每一步都涉及关键的硬件和软件组件，确保最终系统能稳定运行。

---

# **1. 计算机最底层：从通电到操作系统启动**
当你按下计算机的电源按钮，计算机经历了 **一系列步骤** 才能运行你的操作系统。这是编写 OS 需要理解的 **启动流程**。

## **1.1 CPU 加电后执行的第一条指令**
计算机的 CPU 并不会直接运行你的操作系统，而是有一个固定的 **启动流程**（Boot Process）。  
当计算机 **通电** 时：
1. **CPU 初始化**（执行硬件自检）。
2. **CPU 自动执行 BIOS/UEFI 固件**。
3. **BIOS/UEFI 读取启动设备的第一个扇区（MBR 或 GPT）**。
4. **BIOS/UEFI 将启动扇区的代码加载到内存，并让 CPU 执行**。

### **BIOS 与 UEFI**
- **BIOS（Basic Input/Output System）**：老式 PC 的启动固件，使用 **16 位实模式** 运行，最多支持 **2TB 硬盘**。
- **UEFI（Unified Extensible Firmware Interface）**：现代 PC 的启动固件，支持 **32/64 位模式**，可以加载更大的硬盘（>2TB）。

目前大部分 **新电脑使用 UEFI**，但我们自己写操作系统时，一般会用 **BIOS + MBR 启动模式**，因为它更简单。

---

# **2. 硬盘与启动扇区（Boot Sector）**
## **2.1 硬盘的基本单位：扇区**
硬盘是由 **很多扇区（Sector）** 组成的，每个扇区的大小一般是：
- **512 字节**（老式硬盘）
- **4096 字节（4K 扇区）**（新型硬盘）

计算机的 **BIOS 只能读取第一个扇区**，这个 **第一个扇区** 就是 **MBR（Master Boot Record）**，它只有 **512 字节**，但却是操作系统的入口。

## **2.2 MBR（主引导记录）**
- MBR 存储在 **硬盘的第 0 扇区**（LBA 0）。
- 结构如下：
  | 偏移量（Byte） | 内容 |
  |--------------|------|
  | 0x000 - 0x1BD | **引导代码（446 字节）** |
  | 0x1BE - 0x1FD | **分区表（64 字节）** |
  | 0x1FE - 0x1FF | **引导标志 0x55AA（2 字节）** |

其中，**引导代码**（Bootloader）是 CPU 启动时执行的 **第一段代码**，用于加载更大的 OS 内核。

---

# **3. Bootloader（引导程序）**
## **3.1 Bootloader 的作用**
MBR 只有 **512 字节**，太小了，根本装不下操作系统。所以，我们需要写一个 **Bootloader** 来：
1. **切换 CPU 运行模式（16 位 → 32 位 → 64 位）**。
2. **加载更大的内核文件到内存**。
3. **跳转到内核执行**。

## **3.2 CPU 运行模式**
### **（1）16 位实模式（Real Mode）**
- **BIOS 运行在 16 位实模式下**，CPU 只能访问 **1MB** 内存（8086 兼容）。
- 在这个模式下：
  - 只能使用 **16 位寄存器**（AX、BX、CX、DX）。
  - **不能直接访问 1MB 以上的内存**，只能通过 **段寄存器** 访问（CS:IP）。
  - 只有 **BIOS 提供的中断服务** 可用（如 `int 0x10` 进行屏幕输出）。

### **（2）32 位保护模式（Protected Mode）**
- **现代操作系统运行在 32 位或 64 位模式**，所以 Bootloader 需要切换到 **32 位模式**。
- 在 32 位模式下：
  - 直接访问 **4GB** 内存（32 位地址总线）。
  - 可以使用 **内存分页（Paging）** 机制。
  - 不能再使用 BIOS 的中断（需要自己编写驱动程序）。

### **（3）64 位长模式（Long Mode）**
- 64 位 CPU 可以进入 **64 位模式**，支持 **超 4GB 内存**。
- 但是 **BIOS 不能直接引导 64 位模式**，所以 Bootloader 需要：
  - **先进入 32 位模式**，再切换到 **64 位模式**。

---

好的，我们继续深入，从 **操作系统内核（Kernel）** 开始讲起。

---

# **4. 操作系统内核（Kernel）**
## **4.1 什么是内核（Kernel）？**
内核（Kernel）是操作系统的 **核心部分**，它负责：
1. **管理 CPU**：调度进程，决定谁可以运行。
2. **管理内存**：分配和回收内存，提供虚拟内存支持。
3. **管理设备**：驱动程序用于控制硬件，如硬盘、键盘、显示器。
4. **提供系统调用（Syscall）**：让用户程序访问操作系统功能。

当 Bootloader 加载内核后，**CPU 开始执行内核代码**，这标志着操作系统正式启动。

---

## **4.2 内核的分类**
内核可以分为不同类型：
- **单体内核（Monolithic Kernel）**：整个 OS 作为一个大程序运行（如 Linux）。
- **微内核（Microkernel）**：OS 仅提供最基本功能，驱动等模块运行在用户态（如 Minix）。
- **混合内核（Hybrid Kernel）**：结合两者优点（如 Windows NT）。
- **Exokernel** 和 **Unikernel**：研究性内核，极端优化。

一般来说，**写自己的操作系统时，通常从单体内核开始**，因为它的设计较简单，所有功能都运行在 **内核态**（Kernel Mode）。

---

# **5. 进入操作系统的第一步**
## **5.1 CPU 进入保护模式（Protected Mode）**
在 Bootloader 中，我们已经从 **16 位实模式（Real Mode）** 切换到 **32 位保护模式**。保护模式的优势：
1. **可以使用 4GB 内存（32 位地址总线）**。
2. **支持分页机制（Paging）**，可以实现虚拟内存。
3. **支持多任务**，允许多个程序同时运行。

进入 **保护模式** 需要做以下工作：
- **加载 GDT（全局描述符表）**，定义代码段、数据段。
- **设置 CR0 寄存器的 PE（保护模式启用）位**。

示例代码：
```assembly
; 设置 GDT 进入保护模式
lgdt [gdt_descriptor]
mov eax, cr0
or eax, 1      ; 设置 PE 位，启用保护模式
mov cr0, eax
jmp CODE_SEG:init_protected_mode
```

---

## **5.2 内存管理（Memory Management）**
现代操作系统使用 **分页（Paging）** 管理内存：
1. **虚拟地址（Virtual Address）**：程序看到的地址，如 `0x8048000`。
2. **物理地址（Physical Address）**：真实的 RAM 地址，如 `0x00104800`。
3. **页表（Page Table）**：映射虚拟地址 → 物理地址，操作系统可以隔离进程的内存空间。

在 **进入内核** 之前，Bootloader 需要 **设置好页表**，启用分页模式：
```assembly
mov cr3, page_directory  ; 设置页目录基地址
mov eax, cr0
or eax, 0x80000000       ; 启用分页
mov cr0, eax
```

---

## **5.3 进入 64 位长模式（Long Mode）**
现代 CPU 使用 **64 位模式（Long Mode）** 运行：
1. **启用 PAE（物理地址扩展）**，支持 64 位分页。
2. **加载 64 位 GDT**。
3. **切换到 64 位模式**：
```assembly
mov ecx, 0xC0000080   ; 读取 EFER 寄存器
rdmsr
or eax, 0x00000100    ; 设置 LME 位（启用 Long Mode）
wrmsr
```

**当 CPU 进入 64 位模式后，代码需要使用 64 位指令，如 `mov rax, rbx`**。

---

# **6. 内核初始化**
当 CPU 切换到 **保护模式/64 位模式** 并成功加载内核后，内核需要完成以下初始化任务：

## **6.1 解析 Multiboot 头**
Bootloader 通过 **Multiboot 规范** 传递信息给内核，比如：
- **内存大小**（可用 RAM 多少）。
- **启动盘信息**（从哪个磁盘启动）。
- **显存信息**（屏幕分辨率）。

内核启动时会读取这些信息，决定如何管理硬件。

---

## **6.2 初始化内存管理**
**分页表（Page Table）** 需要完成：
1. **映射内核地址**（如 `0xC0000000` 开始）。
2. **映射用户程序地址**（如 `0x8048000`）。
3. **设置堆栈（Stack）**，确保程序运行不会崩溃。

内存管理的关键数据结构：
- **页目录（Page Directory）**
- **页表（Page Table）**
- **物理页框分配器（Physical Page Allocator）**

---

## **6.3 初始化中断和异常处理**
现代 CPU 通过 **中断（Interrupts）** 处理各种事件，比如：
- **硬件中断（Hardware Interrupts）**：键盘、鼠标、定时器等设备发出的信号。
- **软件中断（Software Interrupts）**：程序主动触发的中断，如系统调用 `int 0x80`。
- **异常（Exceptions）**：CPU 在执行指令时检测到错误，如 **除零错误、页错误（Page Fault）** 等。

---

### **6.3.1 IDT（中断描述符表）**
CPU 使用 **IDT（Interrupt Descriptor Table）** 处理中断，每个条目描述：
1. **中断号（Interrupt Number）**：唯一标识中断。
2. **中断处理函数的地址（ISR, Interrupt Service Routine）**。
3. **权限等级（Privilege Level）**：是否允许用户态访问。
4. **门类型（Gate Type）**：描述如何调用中断例程（中断门、陷阱门等）。

#### **初始化 IDT**
操作系统需要：
1. **定义 IDT 结构**，分配空间存放 **256 个中断条目**（每个条目 8 字节）。
2. **设置 IDT 条目**，绑定各个中断处理函数。
3. **加载 IDT 到 CPU**，使用 `lidt` 指令。

**示例代码（初始化 IDT）：**
```assembly
lidt [idt_descriptor]  ; 加载 IDT
sti                   ; 开启中断（STI = Set Interrupt Flag）
```

---

### **6.3.2 8259 PIC（可编程中断控制器）**
早期的 PC 使用 **8259 PIC（Programmable Interrupt Controller）** 处理硬件中断，常见的中断号：
- `0x20` - 时钟中断（每隔 10ms 触发一次）。
- `0x21` - 键盘中断（按键触发）。
- `0x2E` - 硬盘控制器中断。

**重新映射 PIC**
默认情况下，PIC 的中断号和 CPU 预留的中断冲突（如 `0x00` 用于 CPU 除零错误），所以 OS 需要**重新映射**：
```assembly
mov al, 0x11
out 0x20, al  ; 初始化主 PIC
out 0xA0, al  ; 初始化从 PIC

mov al, 0x20
out 0x21, al  ; 设置主 PIC 中断号 0x20（时钟）
mov al, 0x28
out 0xA1, al  ; 设置从 PIC 中断号 0x28（硬盘）
```

现代 CPU **使用 APIC 替代 PIC**，但基本概念相同。

---

### **6.3.3 设置 ISR（中断处理程序）**
每个中断都需要一个 **中断处理函数（ISR, Interrupt Service Routine）**，当中断发生时，CPU 会执行这个函数。

**示例代码（ISR 处理函数）：**
```assembly
isr_common_stub:
    pusha                  ; 保存所有寄存器
    call isr_handler       ; 调用 C 语言的处理函数
    popa                   ; 恢复寄存器
    iret                   ; 返回
```

内核需要：
- **注册 ISR**，让 IDT 关联到 ISR 处理函数。
- **正确恢复寄存器**，避免影响其他进程。

---

## **6.4 任务调度（Multitasking）**
现代操作系统支持**多任务（Multitasking）**，可以同时运行多个程序。  

任务调度的核心概念：
1. **进程（Process）**：一个运行的程序，每个进程有独立的内存空间。
2. **线程（Thread）**：进程内部的执行单元，可以共享内存。
3. **上下文切换（Context Switch）**：CPU 在不同进程间切换执行状态。

### **6.4.1 时钟中断（Timer Interrupt）**
操作系统使用 **时钟中断** 触发任务切换：
- 每隔 **10 毫秒（100Hz）** 触发一次 `IRQ0`（时钟中断）。
- 在中断处理程序中，OS 选择下一个进程执行。

**示例代码（时钟中断处理）：**
```c
void timer_callback() {
    switch_task();  // 切换到下一个任务
}
```

---

## **6.5 进入用户态（User Mode）**
默认情况下，CPU 运行在 **内核态（Ring 0）**，具有最高权限。  
但是用户程序应该运行在 **用户态（Ring 3）**，防止恶意代码影响内核。

### **6.5.1 切换到用户态**
1. **修改 CPU 特权级（CPL, Current Privilege Level）**。
2. **使用 `iret` 指令，切换到 Ring 3**。
3. **分配用户态栈**。

**示例代码（从内核切换到用户态）：**
```assembly
mov ax, DATA_SEG | 3   ; 设置数据段（Ring 3）
mov ds, ax
mov ss, ax
mov esp, user_stack_top ; 设置用户栈
push USER_CODE_SEG | 3  ; 代码段（Ring 3）
push user_entry         ; 入口点
iret                    ; 切换到用户态
```

---

# **7. 文件系统（File System）**
操作系统启动后，需要加载程序、读写磁盘数据，这就涉及到**文件系统（File System）**。

## **7.1 硬盘分区**
常见的分区格式：
- **MBR（Master Boot Record）**：支持 4 个主分区。
- **GPT（GUID Partition Table）**：支持更多分区，适用于 UEFI。

## **7.2 文件系统类型**
不同操作系统使用不同文件系统：
- **FAT32**（MS-DOS / Windows 早期）。
- **NTFS**（Windows）。
- **ext4**（Linux）。
- **XFS、ZFS**（高性能文件系统）。

---

# **8. 系统调用（Syscalls）**
**系统调用（System Calls）** 允许用户程序访问内核功能，如：
- `read()` 读取文件。
- `write()` 写入文件。
- `fork()` 创建新进程。

用户程序不能直接访问硬件，而是通过 **系统调用** 请求 OS 帮忙。  
系统调用通过 **中断 `int 0x80`** 触发。

**示例代码（用户程序调用 `write()`）：**
```assembly
mov eax, 4      ; syscall number (sys_write)
mov ebx, 1      ; stdout
mov ecx, msg    ; message
mov edx, len    ; message length
int 0x80        ; 调用内核
```

---

# **9. 进程管理（Process Management）**
OS 需要管理多个程序，确保它们不会相互干扰。

## **9.1 创建进程**
创建新进程通常使用 `fork()`：
1. **复制当前进程的内存空间**。
2. **创建新的进程控制块（PCB, Process Control Block）**。
3. **新进程开始执行，从 `fork()` 返回**。

**示例代码（C 语言）：**
```c
int pid = fork();
if (pid == 0) {
    printf("我是子进程！\n");
} else {
    printf("我是父进程，子进程 ID: %d\n", pid);
}
```

---

# **10. 设备驱动（Device Drivers）**
OS 需要**驱动程序（Drivers）**控制硬件，比如：
- **显卡驱动（VGA、Bochs）**
- **磁盘驱动（IDE、SATA）**
- **网络驱动（e1000、VirtIO）**

编写驱动程序的关键：
1. **理解硬件通信方式（I/O 端口、PCI 总线）**。
2. **编写驱动代码，读取/写入设备寄存器**。
3. **处理硬件中断，响应设备请求**。

---

# **总结**
至此，我们已经从 **计算机启动 → 内核加载 → 任务调度 → 文件系统 → 进程管理** 讲解了完整的 **OS 启动流程**。

接下来，你可以开始 **编写自己的 OS**，比如：
- **用汇编编写 Bootloader**。
- **用 C 编写内核**。

你希望从哪里开始？ 😊
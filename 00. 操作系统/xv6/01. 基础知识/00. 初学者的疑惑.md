# 00. 初学者的疑惑

## 1. 我编写操作系统后，硬件怎么知道这有个操作系统呢？比如我用C语言来写，难道C语言就直接烧录在计算机硬盘上面吗？

简单来说，计算机硬件只能理解最底层的机器码，而高级语言（如 C 语言）最终都要被编译成机器码，然后才被硬件执行。

1. **编写代码 → 编译为机器码**  
   - 当你用 C 语言写操作系统代码时，你其实是在写人类容易理解的程序。  
   - 然后，你用编译器（比如 gcc）将 C 代码编译成目标文件，接着链接生成最终的内核镜像。  
   - 这个内核镜像其实就是一堆机器码，也就是 CPU 能直接执行的指令。  
   - 换句话说，C 语言不会直接“烧录”到硬盘上，而是经过编译、链接过程，生成一个二进制文件，然后这个二进制文件才是最终存放在硬盘上的。

2. **如何让硬件知道有操作系统**  
   - 在电脑启动时，**BIOS/UEFI** 固件会在启动设备（比如硬盘）的第一个扇区寻找一个有效的启动程序（Bootloader）。  
   - 这个启动扇区（如 MBR）中存放的是一小段机器码，它的最后两个字节通常为 `0x55AA`，这是硬件识别启动扇区的标志。  
   - 当 BIOS/UEFI 发现这个标志，就会加载并执行这段启动代码。  
   - 启动代码的任务是加载更大的内核镜像（你编译好的操作系统），并将控制权交给内核。

3. **操作系统的启动流程**  
   - **固件启动**：通电后，BIOS/UEFI 检查硬件并加载启动扇区。  
   - **Bootloader 执行**：启动扇区中的 Bootloader 代码会加载操作系统内核（即机器码形式的内核）到内存中。  
   - **内核运行**：内核开始执行，它初始化硬件、管理内存、调度任务等，最终构成了整个操作系统。

总结一下，硬件本身并不知道“C 语言”或其他高级语言。你的高级语言代码在编译后变成机器码，而硬件只能理解这些机器码。操作系统存在于硬盘上，是以机器码的形式存储，当启动固件（BIOS/UEFI）加载 Bootloader 并执行后，它会把操作系统内核加载到内存中并运行，这样计算机才能“发现”并运行你的操作系统。

## 2. 为什么操作系统断电后不会消失？是谁把它加载的，难道有比操作系统权限更高的系统来操作他吗？

1. **操作系统存储在硬盘上**  
   - 操作系统实际上是由很多二进制文件组成的集合，其中包含内核、驱动程序、系统工具等。这些文件保存在硬盘、SSD 或其他非易失性存储介质上，所以断电后数据不会消失。

2. **通电启动过程**  
   - 当你按下电源按钮时，电脑首先会执行内置的固件（BIOS 或 UEFI），这些固件存储在主板上的 ROM 或闪存里，是非易失性的。  
   - 固件完成硬件自检（POST）后，会查找启动设备（例如硬盘）的第一个扇区（MBR 或 EFI 分区），其中包含了启动加载程序（Bootloader）。

3. **加载操作系统**  
   - Bootloader 是一个小程序，负责将操作系统内核从硬盘加载到内存中，并把控制权交给内核。  
   - 一旦内核加载并运行，操作系统就开始管理电脑的资源和任务。

4. **比操作系统更高权限的“东西”**  
   - 在这个过程中，**固件（BIOS/UEFI）**是先于操作系统运行的，并且具有更高的权限。  
   - 固件是预先写入硬件的，负责在操作系统启动之前完成硬件初始化和基本检查，它的存在保证了电脑能正确找到并加载操作系统。

总结来说：
- 操作系统存储在硬盘（非易失性存储器）上，所以断电后数据不会丢失；
- 通电后，由固件（BIOS/UEFI）首先运行，它负责加载存储在硬盘上的启动程序，再由启动程序加载操作系统；
- 固件比操作系统具有更高的权限，是电脑启动过程的第一层软件。

这种层级关系保证了即使操作系统本身出现问题，电脑依然可以通过固件进入基本的硬件管理状态。

## 3. 应用程序在运行时，最终是操作系统在操作CPU，还是应用程序的代码在操作CPU？或者说，应用程序在做事情，是他自己在做，还是操作系统在做？

应用程序的代码最终是由 CPU 执行，也就是说，当你的应用程序在运行时，CPU 正在直接执行它编译好的机器码。不过，整个过程是在操作系统的管理和调度下进行的，具体解释如下：

1. **应用程序代码的执行**  
   - 你写的 C 代码经过编译、链接后变成了一堆机器码，保存在硬盘上。当你启动一个应用程序时，这些机器码被加载到内存中，然后 CPU 按照程序的指令一条条执行。

2. **操作系统的作用**  
   - 操作系统负责管理硬件资源，包括 CPU、内存、磁盘和外设。它会决定哪个进程在什么时候可以使用 CPU，也就是说，操作系统调度应用程序的执行。
   - 操作系统还提供了一系列系统调用（如文件操作、网络通信等），应用程序通过这些接口与硬件进行间接交互。

3. **谁在“做事”？**  
   - 当一个应用程序“做事情”时，实际上是它自己的机器码在被 CPU 执行；但是，操作系统在背后起到监督和管理作用，比如分配 CPU 时间片、处理中断和异常等。
   - 所以，你可以理解为：应用程序在执行时，它自己的代码在运作，但这一切都是在操作系统提供的环境中进行的。操作系统就像一个调度员，决定哪个程序什么时候能“上场”，而实际“比赛”是由应用程序自己的代码完成的。

简而言之，CPU执行的是应用程序的机器码，但应用程序能够运行和发挥作用，是因为有操作系统在负责资源管理、调度以及提供必要的系统服务。
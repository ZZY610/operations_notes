# 关系数据模型与关系代数
## 0. 关系代数的本质
关系代数的本质可以用简单易懂的语言来概述为以下几个要点：

### 1. 什么是关系代数？
关系代数是用来操作数据库中表格（关系）的一套数学工具。它定义了一些基本的操作，用于从一个或多个表中提取和处理数据，生成新的表。

### 2. 基本操作有哪些？
关系代数包括几种主要操作，每种操作都对应着一种常见的数据库操作：

- **选择**：挑选出满足某些条件的行。例如，找出所有年龄大于30岁的员工。
- **投影**：选择出特定的列，去掉不需要的列。例如，只显示员工的姓名和部门。
- **联合**：把两个表中的所有行合并在一起，去掉重复的行。例如，合并两个不同部门的员工名单。
- **差集**：从一个表中去掉在另一个表中也存在的行。例如，找出在部门A但不在部门B的员工。
- **笛卡尔积**：把两个表中的每一行两两组合起来，生成一个新表。例如，把所有的员工和所有的项目配对。
- **连接**：根据某个条件，把两个表中的相关行合并在一起。例如，根据员工的部门ID把员工表和部门表合并。

### 3. 为什么关系代数重要？
关系代数的重要性在于它提供了一种结构化、数学化的方法来处理和查询数据。这有几个主要优点：

- **统一性**：所有操作的输入和输出都是表，这使得它们可以很容易地组合在一起形成复杂的查询。
- **清晰性**：每个操作都有明确的定义，使用这些操作可以很清晰地表达数据处理的逻辑。
- **优化性**：数据库系统可以利用关系代数的性质对查询进行优化，提高执行效率。

### 4. 实际应用是什么？
在数据库中编写SQL查询时，实际上是在使用关系代数的概念和操作。关系代数为SQL等查询语言提供了理论基础。

::: tip 关系模型的特点
1. 关系模型建立在严格的数学理论基础之上。
2. 数据结构简单清晰，用户易懂易用。关系模型的数据结构虽然简单，但却能表达丰富的语义，能够较好地描述现实世界的实体以及实体间的各种联系。
3. 数据物理存取路径对用户是透明的，有更高的数据独立性、更好的数据安全性。
:::

## 1. 关系数据结构
### 1.1 二维表与关系数据结构 
![Img](./FILES/02.%20关系数据模型.md/img-20230307100207.png)
* 二维表的特点
（1）每个表具有表名
（2）表由表头和若干行数据两部分构成
（3）表有若干列，每列都有列名
（4）同一列的值必须取自 **同一个域**
（5）每一行的数据代表一个实体的信息

* 一个关系就是一个规范化的二维表。
* “规范化”的含义是：表中每列都是原子项，即没有“表中表”。（这是数据库设计“范式”的内容）
* 一个关系由==关系名==、==关系模式==和==关系实例==组成。通常，它们分别对应于二维表的表名、表头和数据。

#### 术语
* <span style="color:red">关系</span>：一个关系（Relation）指一张二维表。
* <span style="color:red">元组</span>：一个元组（Tuple）指二维表中的一行。
* <span style="color:red">属性</span>：一个属性（Attribute）指二维表中的一列，表中每列均有名称，即属性名。
* <span style="color:red">码</span>（key）：也称键、关键字、关键码，指表中可唯一确定元组的属性或属性组合。
* <span style="color:red">域</span>（Domain）：指属性的取值范围。
* 分量：指元组中的一个属性值。
* <span style="color: rgb(255, 41, 65);">关系模式</span>：是对关系“型”的描述，通常表示为：
$关系名(属性1，属性2，…，属性n)$
![Img](./FILES/02.%20关系数据模型.md/img-20230307101230.png)

### 1.2 关系数据结构的形式化定义 
简而言之，关系表是属性笛卡尔积的有限子集。

- **域 Domin**：一组具有相同数据类型的值的集合。
- **笛卡尔积 Cartesian Product**
    - 给定一组域 $D1，D2，…，Dn$ ，这些域中可以有相同的。$D1，D2，…，Dn$的笛卡儿积为：

        $D1×D2×…×Dn＝｛（d1，d2，…，dn）｜di \in Di，i＝1，2，…，n｝$
        所有域的所有取值的一个组合。
    - 例如，D1=（a,b），D2=（1，2，3），D1×D2={（a,1）,（a,2）,（a,3）,（b,1）,（b,2）,（b,3）}
    - 笛卡尔积的表示方法，实际上就是一张二维表。表每列对应一个域，每行对应一个元组。
    - 两个表也可以有笛卡尔积（广义笛卡尔积），就是交叉连接。实际上就是将每个表的每条记录视为一个值。
- **元组 Tuple**：笛卡尔积中的每个元素称为（d1，...，dn）一个**n元组**，简称**元组**。
- **分量 Component**：元组中的每一个值di称为一个**分量**。
- **基数 Cardinal number**：**笛卡尔积的基数是每个域不同取值的个数的乘积**。如果每个域$Di（i=1，2，...，n）$的基数为mi（即不同取值的个数），则笛卡尔积的基数$M=m_1×m_2×...×m_n$。也即笛卡尔积元组的数量。
- **关系 Relation**：
    - 定义：D1×D2×D3×Dn的子集称为在域D1×D2×D3×Dn上的关系，表示为R(D1,D2,D3,Dn)。R：关系名，n：关系的目或度
    - 关系是笛卡尔积有意义的有限子集。
    - 关系中的每个元素（记录）是元组，用t表示。

### 1.3 关系的性质
（1）列是同质的（Homogeneous），即每列中的分量必须是同一类型的数据。
（2）不同的列可以出自同一个域，但不同的属性必须赋予不同的属性名。
（3）列的顺序可以任意交换。交换时，应连同属性名一起交换。
（4）任意两个元组不能完全相同。
（5）关系中元组的顺序可任意，即可任意交换两行的次序。
（6）分量必须取原子值，即要求每个分量都是不可再分的数据项。

### 1.4 关系模式
* 关系模式（Relation Schema）是型
* 关系是值
* 关系模式是对关系的描述
    * 元组集合的结构
    * 元组语义以及完整性约束条件
    * 属性间的数据依赖关系集合     

#### 定义关系模式
::: tip 定义关系模式
关系模式可形式化地表示为：
$$R（U，D，dom，F）$$

* R ：     关系名
* U ：      组成该关系的属性名集合
* D ：      属性组U中属性所来自的域
* dom ：  属性向域的映象集合
* F ：       属性间的数据依赖关系集合

关系模式通常可简记为
$$ 	R (U)    或    R (A1，A2，…，An)$$
* R： 关系名
* A1，A2，…，An：      属性名
注：域名及属性向域的映象常常直接说明为属性的类型、长度
:::


### 1.5 关系数据库
#### 定义
* 在一个给定的应用领域中，所有实体及实体之间联系的关系的集合构成一个关系数据库。
    * 例如，在研究商品订购管理的问题域中，商品（GoodsInfo）、客户（CustomerInfo）、商品订购（OrderList）这三个关系的集合就构成商品订购数据库。 
#### 关系数据库的型和值
关系数据库也有型和值之分
* 关系数据库的型 称为关系数据库模式，是对关系数据库的描述.

* 关系数据库的值 是这些关系模式在某一时刻对应的关系的集合，通常简称为关系数据库.
#### 空值
* 在关系元组中允许出现空值。
* 空值表示信息的空缺。空值表示未知的值或不存在值。
    * 例如，GoodsOrder关系中，某个商品没有备注信息，则该商品元组的“备注”分量值即为空值。空值一般用关键词NULL表示。 

### 1.6 码
也称**键**

#### 超键
关系中唯一地标识一条数据的属性集合，允许包含冗余信息。超键包括候选键和非候选键。
比如一张学生信息表，（学号、姓名、年龄）可以作为一个超键，但年龄和姓名显然是不必要的。

#### 候选码(Candidate key)
无冗余属性的超键。

设关系 $R(A_1，A_2，…，A_n)$ ，其属性为 $A_1，A_2，…，A_n$ ，属性集 $K$ 为 $R$ 的子集， $K=(A_i，A_j，…，A_k)，1≤i，j，…，k≤n$ 。当且仅当满足下列两个条件时， K 被称为候选码：
* **唯一性**。对关系 R 的任两个元组，其在属性集 $K$ 上的值是不同的。
* **最小性**。属性集 $K=(A_i，A_j，…，A_k)$ 是最小集，即若删除K中的任一属性，K都不满足最小性。 

#### 主码、主属性、非主属性
* 若一个关系有多个候选码，则选定其中一个为主码（Primary key）

* 包含于候选码的属性称为主属性（Prime attribute）。

* 不包含在任何侯选码中的属性称为非主属性（Non-key attribute）

#### 外码
* 如果关系R1的属性或属性组K不是R1的主码，而是另一关系R2的主码，则称K为关系R1的外码（Foreign Key）.
* 并称关系R1为参照关系（Referencing Relation）
* 关系R2为被参照关系（Referenced Relation）

## 2. 关系代数
一种抽象的查询语言。用对关系的运算来表达查询。
* 关系代数表达式的三个要素
    * 运算对象：关系
    * 运算结果：关系
    * 运算符： (集合、专门关系代数、比较、逻辑)

| 运算符 | 记号 | 含义 |
| -- | -- | -- |
| 集合运算符{rowspan=4} | ∪ | **并**：对R和S的要求： 具有相同的目数n。 相应的属性取自同一个域。  R∪S  仍为n目关系，由属于R或属于S的元组组成              R∪S = { t \| t ∈ R∨t ∈S } |
| — | **差**：对R和S的要求： 具有相同的目数n。 相应的属性取自同一个域  R - S  仍为n目关系，由属于R但不属于S的元组组成              R - S = { t \| t∈R∧t∉S } |
| ∩ | 交 |
| × | 笛卡尔积 |
| 专门的关系运算符{rowspan=4} | σ | 选择 |
| Π | 投影 |
| ⨝ | 连接 |
| ÷ | 除法 |
| 比较运算符{rowspan=6} | < | 小于 |
| ≤ | 小于等于 |
| > | 大于 |
| ≥ | 大于等于 |
| = | 等于 | 
| <> | 不等于 | 
| 逻辑运算符{rowspan=3} | ┐ | 非 |
| ∧ | 与 |
| ∨ | 或 |

### 1. 选择 Selection

### 2. 投影 Projection
关系代数中的**投影（Projection）**运算用于从关系（表）中选择指定的属性（列），并生成一个新的关系，只包含所选的属性，而去除其他属性。

#### 注意事项
1. **去重**：在SQL中使用 `SELECT DISTINCT` 可以确保去除重复的元组。关系代数中的投影运算也是默认会去除重复项的。
2. **顺序无关**：投影运算的结果集中的元组顺序是无关紧要的，顺序不影响结果的正确性。

### 3. 连接 Join
根据某个条件，把两个表中的相关行合并在一起。根据条件的不同可以细化为以下几种。

#### 内连接
**内连接**返回两个表中满足连接条件的记录。

- **等值连接（Equi-Join）**：基于相等条件连接两个表的记录。
- **自然连接（Natural Join）**：自动基于**同名**且**相同数据类型**的属性进行等值连接。
- **不等值连接（Non-Equi Join）**：基于非相等条件（如大于、小于等）连接两个表的记录。
- **自连接（Self Join）**：一个表与自身进行连接，用于比较同一表中的行。

#### 外连接
**外连接**返回两个表中满足连接条件的记录，以及某一表或两表中的所有记录。

- **左外连接（Left Outer Join）**：返回左表中的所有记录，即使在右表中没有匹配的记录。
- **右外连接（Right Outer Join）**：返回右表中的所有记录，即使在左表中没有匹配的记录。
- **全外连接（Full Outer Join）**：返回两个表中的所有记录，包括两边没有匹配的记录。

#### 交叉连接
**交叉连接（Cross Join）**：返回两个表的笛卡尔积，即所有可能的记录组合。

### 4. 除法 Division
关系代数中的 **除法（Division）** 通常用于查找在一个关系中匹配所有在另一个关系中的记录。换句话说，除法运算找出那些在第一个关系（表）中的元组（行），这些元组的**某些属性**在第二个关系（表）中的所有元组上都有对应的匹配。

#### 定义
假设有两个关系（表）A和B：

- **A** (被除数)：包含所有元组集合，其中包括我们感兴趣的属性。
- **B** (除数)：包含要匹配的属性子集。

除法运算$(A \div B)$的结果是一个新的关系（表），它包含在A中每一个可以与B中的每一个元组匹配的所有属性。

#### 形式化定义
如果关系A的属性集合为 \( \{X, Y\} \)（X和Y是属性的子集），关系B的属性集合为 \( \{Y\} \)，那么：
- **X** 是A中除去Y后的剩余属性。
- **Y** 是两个关系中共有的属性。

关系A除以关系B，表示为 \( A \div B \)，其结果是一个包含属性集X的关系C，使得对于C中的每个元组 \( c \)，在A中存在一组元组 \( a \) 满足：
- 对于B中的每个元组 \( b \)，都有一个元组 \( a \in A \) 使得 \( a \) 在属性Y上等于 \( b \)，并且 \( a \) 在属性X上的值等于 \( c \)。

#### 实例解释
假设我们有两个表：`orders` 和 `required_quantities`。

#### 表结构和数据
```sql
CREATE TABLE orders (
    order_id INTEGER,
    product_name TEXT,
    quantity INTEGER
);

CREATE TABLE required_quantities (
    quantity INTEGER
);

INSERT INTO orders VALUES 
(1, 'Apple', 10), 
(2, 'Apple', 20), 
(3, 'Banana', 20), 
(4, 'Banana', 30), 
(5, 'Cherry', 10), 
(6, 'Cherry', 30);

INSERT INTO required_quantities VALUES 
(10), 
(20);
```

我们希望找到所有在 `orders` 表中 `product_name` 对应的 `quantity` 满足 `required_quantities` 表中的所有数量。这意味着我们要找出满足所有指定数量的产品。

### 实现除法运算
在SQL中实现除法运算可以分为以下步骤：

1. **创建临时表以存储`required_quantities`中的所有数量**：
```sql
CREATE TABLE quantities2 AS
SELECT DISTINCT quantity
FROM required_quantities;
```

2. **查找满足所有数量条件的产品**：
```sql
SELECT product_name
FROM orders
WHERE quantity IN (SELECT quantity FROM quantities2)
GROUP BY product_name
HAVING COUNT(DISTINCT quantity) = (SELECT COUNT(*) FROM quantities2);
```

### 分步解释
1. **临时表 quantities2**：包含`required_quantities`表中的所有不同数量。
   ```sql
   SELECT DISTINCT quantity FROM required_quantities;
   ```

2. **主查询**：
   - **WHERE 子句**：筛选出 `orders` 表中数量在 `quantities2` 表中的记录。
     ```sql
     WHERE quantity IN (SELECT quantity FROM quantities2)
     ```
   - **GROUP BY**：按 `product_name` 分组。
   - **HAVING 子句**：确保每个 `product_name` 的不同数量的计数与 `quantities2` 表中的数量相同。
     ```sql
     HAVING COUNT(DISTINCT quantity) = (SELECT COUNT(*) FROM quantities2);
     ```

### 示例结果
如果运行上述查询，结果将是：
```plaintext
product_name
-------------
Apple
Cherry
```
这表明产品 `Apple` 和 `Cherry` 的订单数量满足 `required_quantities` 表中的所有数量条件。

### 总结
关系代数中的除法运算用于查找在一个关系中满足所有另一个关系中的条件的元组。这种操作在数据库应用中非常有用，例如查找完成所有特定任务的员工、购买所有指定产品的客户等。通过结合子查询、分组和聚合，可以在SQL中实现这种运算。

## 3. 关系完整性
* 关系模型的完整性规则是对关系的某种**约束条件**。
* 关系模型中三类完整性约束：
    * 实体完整性
    * 参照完整性
    * 用户定义的完整性
* 实体完整性和参照完整性是关系模型必须满足的完整性约束条件，被称作是关系的两个不变性，应该由关系系统自动支持。
### 1. 实体完整性 ( *Entity Integrity* )
* 若属性A是基本关系R的主属性，则属性A不能取空值。
* 根据实体完整性约束，一个关系中不允许存在两类元组：
    * 无主码值的元组
    * 主码值相同的元组

### 2. 参照完整性 
* 关系间的引用：在关系模型中实体及实体间的联系都是用关系来描述的，因此可能存在着关系与关系间的引用。
* 若属性（或属性组）F是基本关系R的**外码**，它与基本关系S的主码KS相对应。则对于R中每个元组在F上的值必须为：
    * 或者取空值（F的每个属性值均为空值）
    * 或者等于S中某个元组的主码值。

### 3. 用户定义完整性

* 用户定义的完整性是针对某一具体关系数据库的约束条件，反映某一具体应用所涉及的数据必须满足的语义要求。

* 关系模型应提供定义和检验这类完整性的机制，以便用统一的系统的方法处理它们，而不要由应用程序承担这一功能。

## 2. 数据冗余与操作异常问题

## 3. 数据库范式
### 第一范式
- 第一范式(1NF)：属性不可再分，即每个属性都是不可分割的原子项。(实体的属性即表中的列)
- 目的：保证表中属性都是原子的

### 第二范式
- 第二范式(2NF)：满足1NF；且不存在部分依赖，即非主属性必须完全依赖于主属性。(主属性即主键；完全依赖是针对于联合主键的情况，非主键列不能只依赖于主键的一部分)
- 目的：消除非主属性对主属性的**部分依赖**

如果不满足2NF，说明表中非主属性部分依赖于主键，存在数据冗余。比如成绩表（学号，姓名，课程，分数），主键是（学号、课程），分数是完全依赖，但姓名是部份依赖，可以拆分表。

### 第三范式
- 第三范式(3NF)：满足2NF；且不存在传递依赖，即非主属性不能与非主属性之间有依赖关系，非主属性必须直接依赖于主属性，不能间接依赖主属性。（A -> B, B ->C, A -> C）
- 目的：消除非主属性对主属性的**传递依赖**

### BCNF范式

- 巴斯范式(BCNF)：满足3NF的基础上，主属性之间不存在部分函数依赖和传递函数依赖。
1. 所有的函数依赖都是完全函数依赖：对于关系中的每个属性组，不存在一个属性可以由其他属性的子集唯一确定。也就是说，每个属性都必须依赖于整个主键。
2. 不存在任何部分函数依赖：关系中的每个非主属性都不能部分地依赖于主键。即非主属性必须完全依赖于主键，不能仅依赖于主键的一部分。
3. 不存在任何传递函数依赖：关系中不存在非主属性之间的传递函数依赖。也就是说，如果 A 依赖于 B，B 依赖于 C，那么 A 不能直接依赖于 C。

- 目的：消除数据库中的冗余和异常，确保数据的完整性和一致性。通过满足 BCNF，可以减少数据的冗余，避免更新异常、插入异常和删除异常等问题。


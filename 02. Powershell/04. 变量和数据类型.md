# 变量和数据类型

## 1. 变量的声明和赋值
在 PowerShell 中，变量用于存储数据。
- 变量名以 `$` 符号开头
- 变量名可以包含字母、数字和下划线，但不能以数字开头
- 变量的声明和赋值非常简单，使用等号 `=` 进行赋值。

```powershell
$myVariable = "Hello, PowerShell!"
$number = 42
$isTrue = $true
```

变量不需要显式声明类型，PowerShell 会自动根据赋值内容推断数据类型。

## 2. 变量的作用域
变量的作用域决定了变量的可访问范围。PowerShell 中的变量作用域包括：
- **Global**: 全局作用域，脚本和所有函数都可以访问。
- **Local**: 局部作用域，只能在当前脚本或函数中访问。
- **Script**: 脚本作用域，整个脚本中都可以访问，但函数中的变量除外。
- **Private**: 私有作用域，只能在当前块中访问。

可以通过 `Set-Variable` cmdlet 或作用域修饰符来指定变量的作用域。

```powershell
$global:myGlobalVariable = "Global Variable"
$local:myLocalVariable = "Local Variable"
$script:myScriptVariable = "Script Variable"
$private:myPrivateVariable = "Private Variable"
```

## 3. 变量扩展

**变量扩展**：在双引号 (`"`) 包裹的字符串中，PowerShell 会自动识别并替换变量为其当前的值。

如果字符串是用单引号 (`'`) 包裹的，PowerShell 则不会进行变量扩展。

::: tip 关键点
- 变量扩展只在双引号中有效。
- 单引号内的字符串不会进行变量扩展。
:::

### 3.1 变量扩展的基本语法和示例

#### 1. **简单变量扩展**
简单的变量扩展就是直接在双引号字符串中使用变量。PowerShell 会自动将变量的值插入到字符串中。

```powershell
$name = "John"
$message = "Hello, $name!"
Write-Output $message

# Hello, John!
```


在这个例子中，`$name` 变量的值 `"John"` 被自动插入到 `$message` 字符串中。

#### 2. **对象属性扩展**
不仅是简单的变量，PowerShell 还可以在字符串中使用对象的属性进行扩展。

```powershell
$date = Get-Date
$message = "Today is $($date.DayOfWeek), the $($date.Day) of $($date.Month), $($date.Year)."
Write-Output $message

# Today is Friday, the 6 of 10, 2024.
```

在这个例子中，`$date` 对象的属性 `DayOfWeek`、`Day`、`Month` 和 `Year` 被插入到字符串中。

#### 3. **数组索引的变量扩展**
可以直接在字符串中引用数组的某个元素：

```powershell
$colors = @("Red", "Green", "Blue")
$message = "My favorite color is $colors[1]."
Write-Output $message

# My favorite color is Green.
```

PowerShell 自动替换数组 `$colors` 中索引为 `1` 的元素。

#### 4. **使用大括号 `{}` 强制变量扩展**
如果变量名后面紧跟其他字符，PowerShell 可能会无法正确识别变量的边界。此时可以使用大括号 `{}` 来明确标记变量名。

```powershell
$name = "John"
$message = "Hello, ${name}son!"
Write-Output $message

# Hello, Johnson!
```

在这里，使用 `${name}` 确保了变量 `$name` 被正确识别，而不至于将整个 `nameson` 视作变量。

### 3.2 常见变量扩展用法

#### 1. **多行文本中的变量扩展**
如果字符串跨越多行，PowerShell 依然会执行变量扩展。

```powershell
$name = "Alice"
$message = @"
Hello, $name!
Welcome to PowerShell scripting.
"@
Write-Output $message
```

输出结果：
```
Hello, Alice!
Welcome to PowerShell scripting.
```

#### 2. **在命令输出中嵌入变量**
你可以将变量扩展与命令结合使用。比如在执行命令时嵌入变量的值：

```powershell
$filename = "report"
$extension = "txt"
$path = "C:\Files\$filename.$extension"
Write-Output $path
```

输出结果：
```
C:\Files\report.txt
```

#### 3. **防止变量扩展的转义**
如果你想在双引号中使用 `$` 符号但不希望 PowerShell 扩展它为变量，可以使用转义符 ```。

```powershell
$message = "The price is `$5."
Write-Output $message
```

输出结果：
```
The price is $5.
```

#### 4. **复杂表达式的扩展**
在字符串中如果你想扩展更复杂的表达式，可以使用 `$()` 来将表达式放入字符串中。这和bash脚本很像。

```powershell
$a = 5
$b = 10
$message = "The sum of $a and $b is $(($a + $b))."
Write-Output $message
```

输出结果：
```
The sum of 5 and 10 is 15.
```

PowerShell 的变量扩展功能为动态字符串生成提供了很大的灵活性。通过双引号和大括号，你可以轻松地将变量、数组、对象的属性，甚至复杂的表达式嵌入到字符串中，极大简化了代码的编写与维护。

## 4. 字符串、数字、布尔值

### 4.1 字符串
用双引号或单引号括起来的文本。如果不用引号括起来，系统会将其视为一个命令。

```powershell
$string1 = "This is a string."
$string2 = 'This is also a string.'
```

PowerShell 在处理字符串时提供了多种功能和操作逻辑，适合日常脚本编写和高级编程需求。以下是 PowerShell 中字符串操作的常用逻辑和示例：

---

#### **1. 字符串创建与基本操作**

##### **创建字符串**
```powershell
# 单引号创建
$single = '这是单引号字符串'

# 双引号创建（支持插值）
$name = 'PowerShell'
$double = "这是一个 $name 字符串"
```

##### **字符串插值**
- 使用双引号时可以直接嵌入变量或表达式。
```powershell
$name = "Alice"
$greeting = "Hello, $name!"
```

---

#### **2. 字符串连接**

##### **使用加号（`+`）**
```powershell
"Hello, " + "World!"
```

##### **使用插值**
```powershell
$name = "Alice"
"Welcome, $name!"
```

##### **使用 `-join` 运算符**
- 用于连接数组中的字符串。
```powershell
$words = @("PowerShell", "is", "fun")
$sentence = -join $words  # 输出 "PowerShellisfun"
$sentenceWithSpace = $words -join " "  # 输出 "PowerShell is fun"
```

---

#### **3. 字符串分割**

##### **使用 `-split`**
```powershell
$string = "Apple, Banana, Cherry"
$fruits = $string -split ", "  # 输出数组 @("Apple", "Banana", "Cherry")
```

---

#### **4. 字符串替换**

##### **使用 `-replace`**
- 支持正则表达式。
```powershell
$string = "PowerShell is powerful"
$newString = $string -replace "powerful", "awesome" 
# 输出 "PowerShell is awesome"
```

---

#### **5. 字符串大小写转换**

##### **转为小写或大写**
```powershell
$string = "Hello World"
$string.ToLower()  # 输出 "hello world"
$string.ToUpper()  # 输出 "HELLO WORLD"
```

---

#### **6. 字符串修剪（去除空白或特定字符）**

##### **去除前后空白**
```powershell
$string = "  Hello World  "
$trimmed = $string.Trim()  # 输出 "Hello World"
```

##### **去除左侧或右侧空白**
```powershell
$string = "  Hello World  "
$leftTrimmed = $string.TrimStart()  # 输出 "Hello World  "
$rightTrimmed = $string.TrimEnd()   # 输出 "  Hello World"
```

---

#### **7. 字符串长度和索引**

##### **获取字符串长度**
```powershell
$string = "PowerShell"
$length = $string.Length  # 输出 10
```

##### **访问特定字符**
```powershell
$string = "PowerShell"
$firstChar = $string[0]  # 输出 "P"
$lastChar = $string[-1]  # 输出 "l"
```

---

#### **8. 查找字符串**

##### **检查是否包含子字符串**
```powershell
$string = "PowerShell is great"
$string.Contains("Power")  # 输出 True
```

##### **检查开头或结尾**
```powershell
$string = "PowerShell"
$startsWith = $string.StartsWith("Power")  # 输出 True
$endsWith = $string.EndsWith("Shell")      # 输出 True
```

##### **获取子字符串位置**
```powershell
$string = "PowerShell"
$index = $string.IndexOf("Shell")  # 输出 5
```

---

#### **9. 提取子字符串（字符串切片）**

##### **使用 `Substring`**
```powershell
$string = "PowerShell"
$sub = $string.Substring(0, 5)  # 输出 "Power"
```

##### **使用切片**
```powershell
$string = "PowerShell"
$sub = $string[0..4] -join ""  # 输出 "Power"
```

---

#### **10. 格式化字符串**

##### **简单替换：变量插值**
```powershell
$name = "Alice"
$age = 30
$message = "Name: $name, Age: $age"  # 输出 "Name: Alice, Age: 30"
```

- 适合简单的变量插值。

##### **高级格式化：`-f` 操作符**
`-f` 操作符类似于 Python 的 `str.format()` 方法，可以进行占位符替换和高级格式化。

1. **基本用法**
   ```powershell
   $name = "Alice"
   $age = 30
   $message = "Name: {0}, Age: {1}" -f $name, $age
   Write-Output $message  # 输出 "Name: Alice, Age: 30"
   ```

2. **指定对齐方式**
   - 左对齐：占位符后跟负号。
   - 右对齐：默认。
   ```powershell
   $message = "Name: {0,-10}, Age: {1,5}" -f "Alice", 30
   Write-Output $message
   # 输出:
   # Name: Alice     , Age:    30
   ```

3. **格式化数字**
   - 指定小数位数：
     ```powershell
     $value = 123.456
     $formatted = "{0:F2}" -f $value  # 输出 "123.46"
     ```

   - 格式化为货币：
     ```powershell
     $value = 1234.56
     $formatted = "{0:C}" -f $value  # 输出 "¥1,234.56" (根据系统区域设置)
     ```

4. **格式化日期**
   ```powershell
   $date = Get-Date
   $formatted = "{0:yyyy-MM-dd}" -f $date  # 输出 "2024-12-25"
   ```

5. **填充与对齐**
   ```powershell
   $message = "ID: {0:D6}" -f 42  # 输出 "ID: 000042"
   ```

---

##### **动态字符串构造：`-replace` 和插值结合**
1. **动态替换**
   ```powershell
   $template = "Hello, {Name}!"
   $name = "Alice"
   $message = $template -replace "{Name}", $name
   Write-Output $message  # 输出 "Hello, Alice!"
   ```

2. **复杂逻辑：通过哈希表**
   ```powershell
   $template = "Name: {Name}, Age: {Age}"
   $values = @{ Name = "Alice"; Age = 30 }
   $message = $template -replace "{(\w+)}", { $values[$args[0]] }
   Write-Output $message  # 输出 "Name: Alice, Age: 30"
   ```

---

#### **11. 字符串与数组**

##### **字符串转数组**
```powershell
$string = "PowerShell"
$array = $string.ToCharArray()  # 输出 @('P', 'o', 'w', 'e', 'r', 'S', 'h', 'e', 'l', 'l')
```

##### **数组转字符串**
```powershell
$array = @('P', 'o', 'w', 'e', 'r')
$string = -join $array  # 输出 "Power"
```

---

#### **12. 高级操作：正则表达式匹配**

##### **使用 `-match`**
```powershell
$string = "PowerShell123"
if ($string -match "\d{3}") {
    Write-Output "String contains a 3-digit number."
}
```

##### **提取匹配内容**
```powershell
$string = "PowerShell123"
if ($string -match "(\d{3})") {
    $number = $matches[1]  # 输出 "123"
}
```

---

#### **13. 反转字符串（示例）**
PowerShell 不直接提供反转字符串的方法，但可以通过数组操作实现：
```powershell
$string = "PowerShell"
$reversed = ($string.ToCharArray() | ForEach-Object {$_})[-1..-10] -join ""
```

---

#### **总结**
PowerShell 提供了丰富的字符串操作功能，涵盖了创建、连接、分割、替换、格式化等各方面需求。这些操作既适合简单脚本开发，又可以用来处理复杂的字符串任务。通过结合正则表达式和高级管道操作，字符串处理的灵活性可以进一步提升。

### 4.2 数字
包括整数和浮点数。

```powershell
$int = 42
$float = 3.14
```

### 4.3 布尔值

只有两个值 `$true` 和 `$false`。

```powershell
$boolTrue = $true
$boolFalse = $false
```

在 PowerShell 中，**变量扩展**（也称为 **变量内插**）是指在字符串中嵌入变量，并自动将其替换为对应的值。这种功能可以大大简化字符串的构建，尤其是在需要动态生成内容时。


## 5. 数组
- **数组**：用于存储一组有序的值。数组使用 `@()` 或逗号分隔的元素列表定义。
- 数组大小固定不变，如果对其进行修改，pwsh会销毁原数组，新建数组。如果增删频繁，对性能的影响比较明显。对此情况，可以使用arraylist。

```powershell
$array1 = @(1, 2, 3, 4)
$array2 = 1, 2, 3, 4

# 访问数组元素使用索引，索引从 0 开始。
$firstElement = $array1[0]  # 1
```

### 5.1 新建数组

#### 1. **直接定义数组**
最简单的方法是使用 `@()` 语法来定义一个数组：
```powershell
# 定义一个包含数字的数组
$array = @(1, 2, 3, 4, 5)

# 定义一个包含不同类型的数组
$mixedArray = @("Hello", 42, $true, (Get-Date))
```
- **解释**：`@()` 是数组的标识符，数组中的元素可以是任何类型。上例中，`mixedArray` 包含字符串、数字、布尔值和日期对象。

#### 2. **使用逗号（,）定义数组**
可以直接使用逗号 `,` 来分隔多个元素，从而生成一个数组：
```powershell
# 使用逗号创建数组
$array = 1, 2, 3, 4, 5
```
- **解释**：逗号 `,` 在 PowerShell 中是用来分隔元素的操作符，用来创建数组或分割元素。

#### 3. **数组的扩展**
可以通过 `+=` 运算符动态向数组中添加元素：
```powershell
# 初始化一个空数组
$array = @()

# 向数组中添加元素
$array += 10
$array += 20
$array += 30,40,50
$array += "Hello"
```
- **解释**：`+=` 会将新元素追加到数组的末尾。

数组合并

```powershell
$x = @(1,2)
$x+= @(3,4)
```


#### 4. **通过集合类型定义数组**
可以使用 PowerShell 的集合类型如 `[System.Collections.ArrayList]` 来创建可变长度数组：
```powershell
# 使用 ArrayList 创建数组
$arrayList = [System.Collections.ArrayList]::new()

# 向 ArrayList 中添加元素
$arrayList.Add(10)
$arrayList.Add("PowerShell")
$arrayList.Add((Get-Date))
```
- **解释**：`ArrayList` 是可变长度数组，可以动态调整大小，相较于常规数组的不可变性，ArrayList 更灵活。

#### 5. **创建固定类型数组**
如果需要固定类型的数组，可以使用 `[type[]]` 语法：
```powershell
# 创建一个仅包含整数的数组
[int[]]$intArray = 1, 2, 3, 4, 5

# 创建一个包含字符串的数组
[string[]]$stringArray = "A", "B", "C"
```
- **解释**：这里的 `[int[]]` 和 `[string[]]` 限制了数组的类型，数组中只能包含指定类型的元素。

#### 6. **使用 `1..n` 语法创建数组**
可以用范围运算符 `..` 来创建一个递增的整数数组：
```powershell
# 创建一个包含1到10的数组
$array = 1..10
```
- **解释**：`1..10` 是一个范围操作符，返回从 1 到 10 的数组。

#### 7. **通过 `ForEach-Object` 创建数组**
也可以通过循环的方式向数组中添加元素：
```powershell
# 使用 ForEach 循环创建数组
$array = @()
1..5 | ForEach-Object { $array += $_ }
```

---

### 5.2 数组中可以包含的元素类型
PowerShell 数组中的元素可以是任何类型，包括但不限于：
1. **字符串**（`string`）
   ```powershell
   $stringArray = @("PowerShell", "Scripting", "Learning")
   ```

2. **整数**（`int`）
   ```powershell
   $intArray = @(10, 20, 30)
   ```

3. **布尔值**（`bool`）
   ```powershell
   $boolArray = @( $true, $false )
   ```

4. **日期对象**（`DateTime`）
   ```powershell
   $dateArray = @((Get-Date), (Get-Date).AddDays(1))
   ```

5. **对象**（例如进程对象）
   ```powershell
   $processArray = @(Get-Process)
   ```

6. **混合类型**（即数组可以包含多种不同类型的元素）
   ```powershell
   $mixedArray = @("PowerShell", 100, $true, (Get-Date))
   ```


在 PowerShell 中，访问数组元素有多种方式。可以通过索引、范围、遍历等方法访问单个元素、多个元素，甚至进行数组的修改。以下是详细介绍并配有多个示例的说明。

### 5.3 访问数组元素

#### 1. **通过索引访问数组元素**
PowerShell 中的数组是基于 0 的索引，也就是说第一个元素的索引是 0。

```powershell
# 定义一个数组
$array = @(10, 20, 30, 40, 50)

# 访问第一个元素（索引为0）
$firstElement = $array[0]  # 输出：10

# 访问第三个元素（索引为2）
$thirdElement = $array[2]  # 输出：30

# 访问最后一个元素（使用负索引）
$lastElement = $array[-1]  # 输出：50
```
- **说明**：`$array[0]` 访问数组的第一个元素，`$array[-1]` 访问数组的最后一个元素，负索引从数组末尾开始计数。

---

#### 2. **访问数组中的多个元素（子数组）**
可以通过定义一个索引范围来访问数组中的一部分元素。索引范围使用 `..` 操作符。

```powershell
# 定义一个数组
$array = @(10, 20, 30, 40, 50)

# 访问索引为1到3的元素（包含索引3）
$subArray = $array[1..3]  # 输出：20, 30, 40
```
- **说明**：`1..3` 表示从索引 1 到索引 3 的元素。

---

#### 3. **访问数组中的部分元素（使用特定索引数组）**
可以通过指定一组索引来访问特定的多个元素，返回一个新数组。

```powershell
# 定义一个数组
$array = @(10, 20, 30, 40, 50)

# 访问索引为 0 和 2 的元素
$selectedElements = $array[0, 2]  # 输出：10, 30
```
- **说明**：`$array[0, 2]` 表示访问索引 0 和 2 的元素。

---

#### 4. **遍历数组（使用 `ForEach-Object` 或 `For` 循环）**

##### 使用 `ForEach-Object` 遍历：
```powershell
# 定义一个数组
$array = @(10, 20, 30, 40, 50)

# 使用 ForEach-Object 遍历每个元素
$array | ForEach-Object { 
    Write-Host "Element: $_"
}
```

##### 使用 `For` 循环遍历：
```powershell
# 定义一个数组
$array = @(10, 20, 30, 40, 50)

# 使用 For 循环遍历每个元素
for ($i = 0; $i -lt $array.Length; $i++) {
    Write-Host "Element at index $i: $($array[$i])"
}
```
- **说明**：`ForEach-Object` 会遍历数组中的每个元素，`$_` 代表当前遍历的元素。而 `For` 循环可以使用索引来访问数组中的元素。

---

#### 5. **访问数组的长度**
可以通过 `.Length` 或 `.Count` 属性获取数组的长度（即元素个数）。

```powershell
# 定义一个数组
$array = @(10, 20, 30, 40, 50)

# 获取数组的长度
$arrayLength = $array.Length  # 输出：5
```
- **说明**：`.Length` 和 `.Count` 都可以用来获取数组中的元素个数。

---

#### 6. **修改数组元素**
可以直接通过索引访问并修改数组中的某个元素。

```powershell
# 定义一个数组
$array = @(10, 20, 30, 40, 50)

# 修改数组中索引为1的元素
$array[1] = 200

# 输出修改后的数组
$array  # 输出：10, 200, 30, 40, 50
```
- **说明**：`$array[1] = 200` 修改了数组中索引为 1 的元素，将 20 改为 200。

---

#### 7. **追加新元素**
可以通过 `+=` 运算符将新元素追加到数组中。

```powershell
# 定义一个数组
$array = @(10, 20, 30)

# 追加一个元素
$array += 40

# 追加多个元素
$array += 50, 60

# 输出结果
$array  # 输出：10, 20, 30, 40, 50, 60
```
- **说明**：`+=` 运算符会将新元素追加到数组末尾，支持添加单个或多个元素。

---

#### 8. **删除数组中的元素**
PowerShell 的标准数组是固定大小的，因此不能直接通过删除某个元素来缩小数组大小。但可以通过 `Where-Object` 创建一个新的数组来过滤掉不需要的元素。

```powershell
# 定义一个数组
$array = @(10, 20, 30, 40, 50)

# 创建一个新数组，排除等于30的元素
$newArray = $array | Where-Object { $_ -ne 30 }

# 输出结果
$newArray  # 输出：10, 20, 40, 50
```
- **说明**：`Where-Object` 可以过滤掉指定的元素，并返回一个新的数组。

---

#### 9. **多维数组访问**
PowerShell 支持多维数组。可以通过索引访问特定的维度和元素。

```powershell
# 定义一个二维数组
$multiArray = @(
    @(1, 2, 3),
    @(4, 5, 6),
    @(7, 8, 9)
)

# 访问二维数组中的元素
$element = $multiArray[1][2]  # 输出：6
```
- **说明**：`$multiArray[1][2]` 访问的是二维数组中索引为 1 的数组中的索引 2 的元素。

---

#### 10. **切片访问（数组的部分）**
在 PowerShell 7 中，可以使用数组的切片访问（类似 Python 的切片语法）。

```powershell
# 定义一个数组
$array = @(10, 20, 30, 40, 50)

# 访问从索引1开始，长度为3的子数组
$slice = $array[1..3]  # 输出：20, 30, 40
```

---

#### 11. **获取数组元素的类型**
通过 `GetType()` 方法，可以获取数组或数组中元素的具体类型。

```powershell
# 定义一个混合类型数组
$mixedArray = @("PowerShell", 100, $true, (Get-Date))

# 获取数组元素的类型
$mixedArray[0].GetType().FullName  # 输出：System.String
$mixedArray[1].GetType().FullName  # 输出：System.Int32
```
- **说明**：`GetType().FullName` 用于获取数组中元素的具体类型。

---

### 总结
- PowerShell 提供了多种灵活的数组访问方式，包括索引访问、范围访问、遍历、修改和删除等操作。
- 数组元素可以是任何类型（字符串、数字、布尔值、对象等），也可以是多维数组或混合类型数组。
- 通过切片、遍历和集合操作，可以轻松操作数组中的数据。



## 6. 哈希表（字典）
- **哈希表**：用于存储**键值对**。哈希表使用 `@{}` 定义。

- PowerShell 不允许创建有重复键的哈希表，每一个键都要唯一指向一个值。
- 值可以是一个数组，甚至另一个哈希表。

```powershell
$hashTable = @{
    Name = "John"
    Age = 30
    Country = "USA"
}

echo $hashTable

Name                           Value
----                           -----
Age                            30
Name                           John
Country                        USA
```

访问哈希表元素使用键名而非索引。

```powershell
$name = $hashTable["Name"]  # John
```

在 PowerShell 7 中，创建哈希表有多种方式，使用的语法简洁且灵活。下面详细介绍几种常用的创建哈希表的方法。

### 6.1 哈希表创建

#### 1. 使用 `@{}` 语法创建哈希表
在 `@{}` 中定义键值对，以逗号分隔。

```powershell
# 创建哈希表，键和值之间用 `=` 号分隔
$hash = @{
    Name  = "Alice"
    Age   = 30
    City  = "New York"
}

# 输出哈希表内容
$hash
```

- `@{}` 是哈希表的声明语法。
- 使用 `=` 将键和值进行关联，键和值可以是任意类型。

#### 2. 动态添加键值对

除了在初始化时定义键值对，你还可以动态地向哈希表中添加键值对。

```powershell
# 创建一个空哈希表
$hash = @{}

# 动态添加键值对
$hash["Country"] = "USA"
$hash["Job"] = "Engineer"

# 输出哈希表内容
$hash
```

- 通过 `[]` 索引的方式，可以为哈希表动态添加键值对。

#### 3. 使用 `New-Object` 创建哈希表

你也可以使用 `New-Object` 命令来创建哈希表，这是面向对象的方式，适合某些复杂场景。

```powershell
# 使用 New-Object 创建哈希表
$hash = New-Object 'System.Collections.Hashtable'

# 添加键值对
$hash["Name"] = "Bob"
$hash["Age"] = 25

# 输出哈希表内容
$hash
```

- `New-Object 'System.Collections.Hashtable'` 创建了一个哈希表对象。
- 可以使用 `[]` 添加或访问键值对。

#### 4. 使用 `[hashtable]` 类型加速器

PowerShell 支持类型加速器来简化某些常见的类型操作。使用 `[hashtable]` 类型加速器可以更明确地创建哈希表。

```powershell
# 使用 [hashtable] 创建哈希表
$hash = [hashtable]@{
    Product  = "Laptop"
    Price    = 1200
}

# 输出哈希表内容
$hash
```

- `[hashtable]` 类型加速器将 `@{}` 明确转换为哈希表类型。

#### 5. 创建有序哈希表（`[ordered]`）

默认情况下，哈希表中的键值对是无序的。如果你需要维护键值对的插入顺序，可以使用 `[ordered]` 类型加速器来创建有序哈希表。

```powershell
# 使用 [ordered] 创建有序哈希表
$orderedHash = [ordered]@{
    First  = 1
    Second = 2
    Third  = 3
}

# 输出有序哈希表内容
$orderedHash
```

- `[ordered]` 将哈希表变成有序的哈希表，键值对会按照插入顺序进行存储和输出。

#### 6. 从其他数据结构构建哈希表

你可以使用其他数据结构（如数组、对象等）动态构建哈希表。

```powershell
# 创建对象
$person = [pscustomobject]@{
    Name = "Carol"
    Age  = 22
    Job  = "Designer"
}

# 将对象属性转换为哈希表
$hash = $person | Get-Member -MemberType Properties | 
         ForEach-Object { $_.Name = $person.$($_.Name) }

# 输出哈希表内容
$hash
```

- 通过 `Get-Member` 获取对象的属性，并构建哈希表，将属性名称作为键，属性值作为值。

#### 7. 从键值对列表创建哈希表

在某些情况下，你可能已经有一组键值对，可以将其转换为哈希表。

```powershell
# 键值对列表
$keys = @("Name", "Age", "City")
$values = @("David", 29, "Boston")

# 创建哈希表
$hash = @{}
for ($i = 0; $i -lt $keys.Count; $i++) {
    $hash[$keys[$i]] = $values[$i]
}

# 输出哈希表内容
$hash
```

- 通过遍历键和值的列表，动态创建哈希表。

#### 8. 使用 `Add()` 方法添加键值对

除了 `[]` 索引方式外，你还可以使用 `Add()` 方法添加键值对。

```powershell
# 创建哈希表
$hash = @{}

# 使用 Add 方法添加键值对
$hash.Add("Name", "Eva")
$hash.Add("Age", 35)

# 输出哈希表内容
$hash
```

- `Add(Key, Value)` 方法可以用来添加键值对。

---

#### 总结表格

| 方法                                | 说明                                   | 示例                              |
|-------------------------------------|--------------------------------------|----------------------------------|
| `@{}`                               | 最常见的方式，直接定义键值对             | `@{Name="Alice"; Age=30}`        |
| `New-Object`                        | 使用面向对象的方式创建哈希表              | `New-Object 'System.Collections.Hashtable'` |
| `[hashtable]` 类型加速器              | 使用类型加速器显式创建哈希表              | `[hashtable]@{Key="Value"}`      |
| `[ordered]` 类型加速器               | 创建有序哈希表，按插入顺序存储键值对       | `[ordered]@{Key="Value"}`        |
| 动态添加键值对                       | 通过 `[]` 或 `Add()` 添加键值对          | `$hash["Key"] = "Value"`         |
| 从对象属性构建哈希表                 | 将对象的属性转换为哈希表                 | 使用 `Get-Member` 构建           |
| 从键值对数组构建哈希表               | 从键值对数组动态构建哈希表               | `for ($i = 0; $i -lt $keys.Count; $i++)` |

以上这些方法为你提供了在 PowerShell 7 中创建和操作哈希表的灵活手段。哈希表的键和值可以是任意数据类型，适合各种快速查找和映射数据的场景。

在 PowerShell 7 中，访问哈希表的键和值有多种方式，可以通过键访问单个元素，也可以遍历整个哈希表来获取所有键值对。下面将详细介绍访问哈希表的所有常用方式，并给出丰富的示例。

---
### 6.2 哈希表访问

#### 1. 使用 `[]` 访问键值

最常用的方式是通过键来访问哈希表中的特定值。使用 `[]` 来指定键，获取对应的值。

```powershell
# 创建哈希表
$hash = @{
    Name = "Alice"
    Age  = 30
    City = "New York"
}

# 通过键访问值
$name = $hash["Name"]
$age = $hash["Age"]

# 输出
$name   # 输出: Alice
$age    # 输出: 30
```

---

#### 2. 使用点运算符 `.` 访问键值

对于键是有效的标识符（字母、数字，不含特殊字符）的情况，可以使用点运算符 `.` 来简化访问。

```powershell
# 创建哈希表
$hash = @{
    Name = "Bob"
    Age  = 25
}

# 使用点运算符访问值
$name = $hash.Name
$age = $hash.Age

# 输出
$name   # 输出: Bob
$age    # 输出: 25
```

- 点运算符只能用于有效的标识符键（例如字母或数字组成的键）。
- 这是简化的访问方式，但不适用于包含特殊字符的键。

---

#### 3. 遍历哈希表的键和值

你可以通过 `foreach` 循环遍历哈希表中的所有键值对。通过 `GetEnumerator()` 方法，可以枚举哈希表中的每一个键值对。

```powershell
# 创建哈希表
$hash = @{
    Name  = "Carol"
    Age   = 22
    City  = "Boston"
}

# 遍历键值对
foreach ($item in $hash.GetEnumerator()) {
    $key = $item.Key
    $value = $item.Value
    Write-Host "Key: $key, Value: $value"
}
```

- 使用 `GetEnumerator()` 方法可以枚举哈希表中的每个键值对。
- 每次迭代时，可以通过 `.Key` 和 `.Value` 来获取当前键值对。

---

#### 4. 使用 `Keys` 和 `Values` 属性访问键和值

哈希表的 `Keys` 和 `Values` 属性分别返回哈希表中所有的键和所有的值。

```powershell
# 创建哈希表
$hash = @{
    Product = "Laptop"
    Price   = 1200
}

# 获取所有键
$keys = $hash.Keys
# 获取所有值
$values = $hash.Values

# 输出
$keys    # 输出: Product, Price
$values  # 输出: Laptop, 1200
```

- 使用 `Keys` 属性获取哈希表中的所有键。
- 使用 `Values` 属性获取哈希表中的所有值。

---

#### 5. 使用 `ContainsKey()` 方法检查键是否存在

在访问哈希表前，可以使用 `ContainsKey()` 方法检查哈希表中是否存在某个键，以避免访问不存在的键引发错误。

- `ContainsKey()` 方法用于检查哈希表中是否存在指定键，返回布尔值。
```powershell
# 创建哈希表
$hash = @{
    Name = "David"
    Age  = 40
}

# 检查键是否存在
if ($hash.ContainsKey("Name")) {
    Write-Host "The key 'Name' exists."
} else {
    Write-Host "The key 'Name' does not exist."
}

if ($hash.ContainsKey("Address")) {
    Write-Host "The key 'Address' exists."
} else {
    Write-Host "The key 'Address' does not exist."
}
```

---

#### 6. 使用 `TryGetValue()` 方法获取键值

- `TryGetValue()` 方法尝试获取指定键的值，返回布尔值，表示该键是否存在。若存在，则通过引用类型 `$value` 返回值。并避免抛出异常。
```powershell
# 创建哈希表
$hash = @{
    Name = "Eva"
    Age  = 35
}

# 使用 TryGetValue 获取值
$exists = $hash.TryGetValue("Name", [ref]$value)
if ($exists) {
    Write-Host "Value of 'Name': $value"
} else {
    Write-Host "'Name' does not exist."
}
```

#### 总结表格

| 访问方式                                  | 说明                                      | 示例                                       |
|-------------------------------------------|-------------------------------------------|--------------------------------------------|
| `[]` 索引访问                             | 通过键直接访问值                          | `$hash["Key"]`                             |
| 点运算符 `.` 访问                         | 用于有效标识符的键                        | `$hash.Key`                                |
| `GetEnumerator()` 遍历键值对               | 枚举哈希表中的每个键值对                 | `foreach ($item in $hash.GetEnumerator())` |
| `Keys` 属性                               | 获取所有键                                | `$hash.Keys`                               |
| `Values` 属性                             | 获取所有值                                | `$hash.Values`                             |
| `ContainsKey()` 方法检查键                | 检查哈希表中是否存在指定键               | `$hash.ContainsKey("Key")`                 |
| `TryGetValue()` 方法                      | 尝试获取指定键的值并避免异常              | `$hash.TryGetValue("Key", [ref]$value)`    |


在 PowerShell 中，哈希表是一种非常灵活的数据结构，可以方便地进行键值对的添加和修改操作。PowerShell 7 提供了多种方式来添加和修改哈希表中的元素。以下是详细的介绍及示例。

---
### 6.3 哈希表修改

#### 1. 使用 `[]` 语法添加新元素

最常见的方式是使用 `[]` 语法添加新的键值对。如果键在哈希表中不存在，这种方式会将该键和对应的值添加到哈希表中。

```powershell
# 创建哈希表
$hash = @{
    Name = "Alice"
}

# 添加新键值对
$hash["Age"] = 30
$hash["City"] = "New York"

# 输出哈希表
$hash
```

- 如果指定的键不存在，使用 `[]` 语法会创建该键并赋予它一个新值。

---

#### 2. 使用 `Add()` 方法添加新元素

`Add()` 方法是专门用于添加新键值对的方法。如果试图添加的键已经存在，它会抛出错误。

```powershell
# 创建哈希表
$hash = @{
    Name = "Bob"
}

# 添加新键值对
$hash.Add("Age", 25)
$hash.Add("Country", "USA")

# 输出哈希表
$hash
```

- `Add()` 方法只能用于添加新键，如果键已经存在，会抛出错误。

---

#### 3. 修改现有键的值

和添加键值对类似，使用 `[]` 语法不仅可以添加新键值对，还可以修改现有键的值。

```powershell
# 创建哈希表
$hash = @{
    Name = "Carol"
    Age  = 22
}

# 修改现有键的值
$hash["Age"] = 23
$hash["City"] = "Los Angeles"  # 动态添加新键

# 输出哈希表
$hash
```

- 通过 `[]` 语法可以直接修改已经存在的键的值，同时也能添加新键。

---

#### 4. 使用 `Set_Item()` 方法添加或修改元素

`Set_Item()` 方法提供了类似 `[]` 的功能，可以用于添加新的键值对或者修改现有的键值。

```powershell
# 创建哈希表
$hash = @{
    Name = "David"
}

# 使用 Set_Item 添加或修改元素
$hash.Set_Item("Age", 40)    # 添加新元素
$hash.Set_Item("Name", "Daniel")  # 修改现有元素

# 输出哈希表
$hash
```

- `Set_Item()` 方法和 `[]` 的行为类似，用于添加或更新哈希表中的键值。

---

#### 5. 批量添加键值对

可以一次性添加多个键值对，将一个哈希表的内容合并到另一个哈希表中。

```powershell
# 创建第一个哈希表
$hash1 = @{
    Name = "Eva"
    Age  = 35
}

# 创建第二个哈希表
$hash2 = @{
    City  = "Paris"
    Country = "France"
}

# 批量添加哈希表键值对
$hash1 += $hash2

# 输出哈希表
$hash1
```

- 使用 `+=` 可以将另一个哈希表的内容批量添加到现有哈希表中。如果键已存在，会覆盖原有值。

---

#### 6. 动态生成键名

如果需要动态生成键名，可以通过变量构造键名，并使用 `[]` 来赋值。

```powershell
# 创建哈希表
$hash = @{
    Name = "Frank"
}

# 动态生成键名
for ($i = 1; $i -le 3; $i++) {
    $hash["Item$i"] = $i * 10
}

# 输出哈希表
$hash
```

- 可以通过变量动态生成键名，并通过 `[]` 添加或修改哈希表中的键值对。

---

#### 7. 条件添加或修改元素

可以根据条件来判断是否需要添加或修改哈希表中的某个键值对。

```powershell
# 创建哈希表
$hash = @{
    Name = "Grace"
}

# 根据条件添加或修改
if (-not $hash.ContainsKey("Age")) {
    $hash["Age"] = 28  # 如果不存在"Age"，则添加
} else {
    $hash["Age"] = 29  # 如果已存在"Age"，则修改
}

# 输出哈希表
$hash
```

- 通过条件判断，可以灵活地控制是否添加或修改哈希表中的键值对。

---

#### 8. 合并两个哈希表

可以通过循环遍历或者使用 `+=` 操作符将两个哈希表进行合并。

```powershell
# 创建两个哈希表
$hash1 = @{
    Name = "Henry"
    Age  = 45
}
$hash2 = @{
    Age   = 50  # 这个键值会覆盖 $hash1 的 Age
    City  = "Berlin"
}

# 合并哈希表
$hash1 += $hash2

# 输出合并后的哈希表
$hash1
```

- 如果两个哈希表中有相同的键，合并时后者的值会覆盖前者的值。

---

#### 总结表格

| 方法                                      | 用途                                  | 示例                                                         |
|-------------------------------------------|---------------------------------------|--------------------------------------------------------------|
| `[]` 索引添加或修改元素                  | 用于添加新的键值对或修改现有键的值    | `$hash["Key"] = "Value"`                                      |
| `Add()` 方法                              | 添加新的键值对，键已存在时会抛出错误  | `$hash.Add("Key", "Value")`                                   |
| `Set_Item()` 方法                         | 添加或修改键值对                      | `$hash.Set_Item("Key", "Value")`                              |
| `+=` 操作符                               | 批量添加或合并键值对                  | `$hash1 += $hash2`                                            |
| 动态生成键名                              | 根据变量动态生成键名                  | `$hash["Item$i"] = $i * 10`                                   |
| 条件添加或修改元素                        | 根据条件判断是否添加或修改键值对      | `if (-not $hash.ContainsKey("Key")) { $hash["Key"] = "Value" }`|
| 合并两个哈希表                            | 将两个哈希表合并                      | `$hash1 += $hash2`                                            |

在 PowerShell 中，删除哈希表中的元素有多种方法，既可以通过直接删除指定的键，也可以使用条件删除，甚至可以清空整个哈希表。下面详细介绍删除哈希表元素的所有方式，附带示例和总结表格。

---

### 6.4 哈希表删除

### 1. 使用 `Remove()` 方法删除元素

PowerShell 提供了 `Remove()` 方法，专门用于删除哈希表中的指定键。如果键不存在，不会抛出错误。

```powershell
# 创建哈希表
$hash = @{
    Name = "Alice"
    Age  = 25
    City = "New York"
}

# 删除键 "Age"
$hash.Remove("Age")

# 输出哈希表
$hash
```

- `Remove()` 方法只删除指定键，如果键不存在，哈希表保持不变。

---

### 2. 使用 `Remove()` 方法删除多个元素

可以通过循环使用 `Remove()` 方法删除多个键。

```powershell
# 创建哈希表
$hash = @{
    Name    = "Bob"
    Age     = 30
    Country = "USA"
    City    = "Los Angeles"
}

# 定义需要删除的键
$keysToRemove = @("Age", "City")

# 通过循环删除多个元素
foreach ($key in $keysToRemove) {
    $hash.Remove($key)
}

# 输出哈希表
$hash
```

- 通过遍历数组，可以动态删除多个指定的键。

---

### 3. 使用 `RemoveAt()` 方法删除元素

PowerShell 的 `RemoveAt()` 方法用于删除哈希表中的某个键值对，但必须指定索引（即哈希表中的键的顺序）。由于哈希表是无序的，因此 `RemoveAt()` 并不常用，也不是哈希表的原生方法。它适用于某些特殊类型如 `ArrayList`，而不是标准的 PowerShell 哈希表。

---

### 4. 使用 `Clear()` 方法清空哈希表

如果需要删除哈希表中的所有元素，可以使用 `Clear()` 方法。此方法会删除哈希表中的所有键值对，将哈希表重置为空。

```powershell
# 创建哈希表
$hash = @{
    Name = "Carol"
    Age  = 22
    City = "Paris"
}

# 清空哈希表
$hash.Clear()

# 输出哈希表
$hash  # 输出：{}
```

- `Clear()` 方法会删除哈希表中所有的键值对，返回一个空哈希表。

---

### 5. 使用 `ContainsKey()` 进行条件删除

可以通过 `ContainsKey()` 方法先检查哈希表中是否存在某个键，然后有条件地删除这个键。这种方式可以避免试图删除不存在的键。

```powershell
# 创建哈希表
$hash = @{
    Name = "David"
    Age  = 40
}

# 如果哈希表包含键 "Age"，则删除它
if ($hash.ContainsKey("Age")) {
    $hash.Remove("Age")
}

# 输出哈希表
$hash
```

- 通过 `ContainsKey()` 方法，可以在删除之前检查键是否存在，以防止错误。

---

### 6. 删除符合条件的多个元素

可以结合条件判断和 `Remove()` 方法删除符合某些条件的多个元素。例如，删除所有键的值是字符串的元素。

```powershell
# 创建哈希表
$hash = @{
    Name  = "Eva"
    Age   = 35
    City  = "Berlin"
    Email = "eva@example.com"
}

# 遍历哈希表并删除值类型为字符串的元素
foreach ($key in $hash.Keys) {
    if ($hash[$key] -is [string]) {
        $hash.Remove($key)
    }
}

# 输出哈希表
$hash
```

- 通过 `-is` 运算符，可以根据值的类型进行条件判断，删除符合条件的元素。

---

### 7. 删除键存在的元素并返回结果

有时你可能希望删除元素的同时还能返回被删除的值。PowerShell 中并没有直接支持这种方式，但可以通过自定义函数实现。

```powershell
# 创建哈希表
$hash = @{
    Name = "Frank"
    Age  = 28
}

# 自定义函数：删除键并返回其值
function Remove-And-Return {
    param ($hashTable, $key)
    
    if ($hashTable.ContainsKey($key)) {
        $value = $hashTable[$key]
        $hashTable.Remove($key)
        return $value
    }
    return $null
}

# 调用函数
$removedValue = Remove-And-Return -hashTable $hash -key "Age"

# 输出被删除的值和哈希表
$removedValue
$hash
```

- 通过自定义函数，可以实现删除键值的同时返回被删除的值。

---

#### 总结表格

| 方法                                       | 用途                                  | 示例                                                         |
|--------------------------------------------|---------------------------------------|--------------------------------------------------------------|
| `Remove("Key")`                            | 删除指定的键值对                      | `$hash.Remove("Key")`                                         |
| `RemoveAt()`                               | 根据索引删除元素（适用于特殊情况）    | 不推荐在哈希表中使用，适用于 `ArrayList` 类型                 |
| `Clear()`                                  | 清空哈希表                            | `$hash.Clear()`                                               |
| `ContainsKey()` + `Remove()`               | 先检查键是否存在，再删除              | `if ($hash.ContainsKey("Key")) { $hash.Remove("Key") }`       |
| 自定义函数删除并返回被删除值               | 删除键同时返回值                      | `$removedValue = Remove-And-Return -hashTable $hash -key "Key"`|
| 根据条件删除键值对                         | 根据值或键的条件删除元素              | `if ($hash[$key] -is [string]) { $hash.Remove($key) }`         |
| 循环遍历删除多个键                        | 通过循环批量删除指定键                | `foreach ($key in $keysToRemove) { $hash.Remove($key) }`      |

---

通过以上方法，PowerShell 提供了多种灵活的方式来删除哈希表中的键值对，涵盖从简单的单键删除到条件删除和批量删除等多种需求。

## 7. arraylist

`ArrayList` 是一种动态数组，与标准的 PowerShell 数组不同，它的大小是可以动态调整的。`ArrayList` 是 .NET 框架中 `System.Collections.ArrayList` 类的实现。

- `ArrayList` 适合频繁进行增删操作的场景，因为它的性能比普通数组更高效。

### 1. **创建 `ArrayList`**
可以通过以下方式创建一个 `ArrayList` 实例：

#### 1、使用 `New-Object` 创建
```powershell
# 创建一个空的 ArrayList
$arrayList = New-Object -TypeName 'System.Collections.ArrayList'

# 或者带有初始元素
$arrayList = New-Object 'System.Collections.ArrayList' @(1, 2, 3)
```

#### 2、使用类加速器 `[System.Collections.ArrayList]`
```powershell
# 创建一个空的 ArrayList
$arrayList = [System.Collections.ArrayList]::new()

# 或者带有初始元素
$arrayList = [System.Collections.ArrayList]::new(1, 2, 3)
```

---

### 2. **添加元素**
`ArrayList` 的大小是动态调整的，因此可以轻松地在运行时向其中添加元素。与 PowerShell 的标准数组不同，标准数组是固定大小的，`ArrayList` 更适合频繁的增删操作。

- 使用 `Add` 方法
```powershell
# 创建一个空的 ArrayList
$arrayList = [System.Collections.ArrayList]::new()

# 添加单个元素
$arrayList.Add(10)

# 添加多个元素
$arrayList.AddRange(20, 30, 40)

# 输出 ArrayList
$arrayList  # 输出：10, 20, 30, 40
```

---

### 3. **访问 `ArrayList` 中的元素**
可以像普通 PowerShell 数组一样通过索引访问 `ArrayList` 中的元素，索引从 0 开始。

```powershell
# 访问 ArrayList 中的元素
$firstElement = $arrayList[0]  # 获取第一个元素，输出：10
$secondElement = $arrayList[1]  # 获取第二个元素，输出：20
```

---

### 4. **修改 `ArrayList` 中的元素**
可以通过索引修改 `ArrayList` 中的元素。

```powershell
# 修改 ArrayList 中的第二个元素
$arrayList[1] = 25

# 输出修改后的 ArrayList
$arrayList  # 输出：10, 25, 30, 40
```

---

### 5. **删除元素**
`ArrayList` 提供了多种删除元素的方式，可以通过索引删除元素，也可以直接移除指定的元素，和python很像。

- 示例 1：使用 `Remove` 方法按值删除
```powershell
# 删除值为 25 的元素
$arrayList.Remove(25)

# 输出 ArrayList
$arrayList  # 输出：10, 30, 40
```

- 示例 2：使用 `RemoveAt` 方法按索引删除
```powershell
# 删除索引为 1 的元素（即 30）
$arrayList.RemoveAt(1)

# 输出 ArrayList
$arrayList  # 输出：10, 40
```

- 示例 3：使用 `Clear` 方法清空整个 `ArrayList`
```powershell
# 清空 ArrayList 中的所有元素
$arrayList.Clear()

# 输出空的 ArrayList
$arrayList  # 输出：System.Collections.ArrayList with no elements
```

---

### 6. **获取 `ArrayList` 的长度**
可以通过 `.Count` 属性获取 `ArrayList` 的元素数量（类似于 PowerShell 普通数组的 `.Length` 属性）。

#### 示例：
```powershell
# 获取 ArrayList 的长度
$count = $arrayList.Count  # 输出：2
```

- **说明**：`.Count` 是 `ArrayList` 中的属性，用于获取其长度。

---

### 7. **插入元素**
可以在 `ArrayList` 中的指定索引位置插入元素，其他元素会自动向后移动。

#### 示例：
```powershell
# 创建一个新的 ArrayList
$arrayList = [System.Collections.ArrayList]::new(10, 20, 30)

# 在索引为1的位置插入新元素15
$arrayList.Insert(1, 15)

# 输出 ArrayList
$arrayList  # 输出：10, 15, 20, 30
```

- **说明**：`Insert` 方法用于在特定位置插入元素。

---

### 8. **搜索元素**
`ArrayList` 支持查找元素的索引，使用 `IndexOf` 方法可以返回某个元素第一次出现的索引。如果找不到，返回 `-1`。

#### 示例：
```powershell
# 获取元素 20 的索引
$index = $arrayList.IndexOf(20)  # 输出：2
```

- **说明**：`IndexOf` 用于查找元素的索引，若找不到则返回 `-1`。

---

### 9. **遍历 `ArrayList`**
可以使用 `ForEach-Object` 或 `For` 循环来遍历 `ArrayList`，和 PowerShell 普通数组一样。

#### 示例：使用 `ForEach-Object`
```powershell
# 遍历 ArrayList
$arrayList | ForEach-Object {
    Write-Host "Element: $_"
}
```

#### 示例：使用 `For` 循环
```powershell
# 使用 For 循环遍历 ArrayList
for ($i = 0; $i -lt $arrayList.Count; $i++) {
    Write-Host "Element at index $i: $($arrayList[$i])"
}
```

- **说明**：`ForEach-Object` 和 `For` 循环都可以用来遍历 `ArrayList`。

---

### 10. **`ArrayList` 与普通数组的区别**
- **大小动态调整**：`ArrayList` 是动态大小的，添加或删除元素不会生成新数组。普通数组是固定大小的，每次修改都会生成一个新的数组。
- **性能**：由于 `ArrayList` 的动态特性，频繁的增删操作时性能优于普通数组。
- **方法丰富**：`ArrayList` 具有更多的操作方法，如 `Add`、`Remove`、`Insert`、`Clear` 等。

---

### 11. **`ArrayList` 的元素类型**
`ArrayList` 的元素可以是任何类型，包括数字、字符串、布尔值、对象，甚至其他数组或 `ArrayList`。

#### 示例：
```powershell
# 创建一个混合类型的 ArrayList
$mixedArrayList = [System.Collections.ArrayList]::new()

# 添加不同类型的元素
$mixedArrayList.Add(100)  # 数字
$mixedArrayList.Add("Hello")  # 字符串
$mixedArrayList.Add($true)  # 布尔值
$mixedArrayList.Add((Get-Date))  # 日期

# 输出 ArrayList
$mixedArrayList  # 输出：100, "Hello", True, 当前日期
```

- **说明**：`ArrayList` 允许混合类型的元素，不受数据类型的限制。

---

### 12. **`ArrayList` 的性能**
`ArrayList` 在频繁增删操作时性能更好，因为它是动态调整大小的，而 PowerShell 标准数组每次增删都会生成一个新的数组。

#### 示例：性能对比
```powershell
# 使用标准数组添加元素（性能较低）
$array = @(1, 2, 3)
$array += 4  # 标准数组每次修改都生成新数组

# 使用 ArrayList 添加元素（性能较高）
$arrayList = [System.Collections.ArrayList]::new(1, 2, 3)
$arrayList.Add(4)  # 动态调整大小，不生成新数组
```

- **说明**：`ArrayList` 的动态调整机制适合频繁增删操作，避免了标准数组每次修改都生成新数组的问题。

---

### 总结
`ArrayList` 是 PowerShell 中一种非常灵活和高效的数组类型，适合处理需要频繁增删操作的数据。它提供了比普通数组更多的功能，如动态调整大小、增删插入元素、查找元素等。同时，它可以容纳任何类型的元素，是处理混合数据类型的强大工具。在使用 `ArrayList` 时，可以利用 .NET 提供的丰富方法来简化操作。


## 8. 类型转换
PowerShell 支持自动类型转换，但有时需要显式转换。可以使用 `[类型]` 强制转换。

```powershell
$intString = "123"
$intValue = [int]$intString  # 123

$boolString = "True"
$boolValue = [bool]$boolString  # $true
```

常见的数据类型包括 `[int]`、`[string]`、`[bool]`、`[array]`、`[hashtable]` 等。

在 PowerShell (pwsh) 中，类型转换是将一个对象转换为另一种类型的过程。类型转换在数据处理、脚本编写以及与不同类型数据的交互中非常重要。`PSCustomObject` 作为一种灵活的数据结构，允许我们创建具有自定义属性的对象，且可以在不同类型之间进行转换。下面详细介绍类型转换的相关知识，尤其是与 `PSCustomObject` 相关的内容。

### 5.1 类型转换的基本概念

在 PowerShell 中，类型转换有两种主要方式：

- **隐式转换 (Implicit Conversion)**：PowerShell 自动将某种类型的数据转换为另一种类型。这通常发生在 PowerShell 能够自动推断出所需的类型时。
  
- **显式转换 (Explicit Conversion)**：你明确指定要将数据转换为某种类型。这通常使用类型加上括号来实现，如 `[int]`, `[string]`, `[PSCustomObject]` 等。

### 5.2 类型转换的常见方式

#### 2.1 隐式转换

隐式转换是当 PowerShell 自动检测并执行类型转换时发生的。例如，将一个字符串与数字相加时，PowerShell 会自动尝试将字符串转换为数字。

```powershell
$a = "10"
$b = 5
$c = $a + $b  # 隐式将 $a 转换为 int
Write-Output $c  # 输出 15
```

#### 2.2 显式转换

显式转换是你通过在变量前指定类型来强制转换变量类型的过程。例如，将一个字符串转换为整数：

```powershell
$a = "10"
$b = [int]$a  # 显式将 $a 转换为 int
Write-Output $b  # 输出 10，类型为 int
```

### 5.3 `PSCustomObject` 与类型转换

`PSCustomObject` 是 PowerShell 中用于创建自定义对象的一种类型。它允许你定义具有任意属性的对象，适合表示复杂数据结构。

#### 5.3.1 创建 `PSCustomObject`

创建 `PSCustomObject` 通常使用哈希表的语法，并通过 `[PSCustomObject]` 转换为自定义对象。

```powershell
$person = [PSCustomObject]@{
    Name  = "Alice"
    Age   = 30
    Email = "alice@example.com"
}

Write-Output $person
```

#### 5.3.2 `PSCustomObject` 类型转换

`PSCustomObject` 作为一个通用数据结构，可以转换为其他类型，特别是在需要与不同数据格式（如 JSON、XML 等）交互时。

##### 1 转换为哈希表

可以通过强制转换将 `PSCustomObject` 转换回哈希表：

```powershell
$person = [PSCustomObject]@{
    Name  = "Alice"
    Age   = 30
    Email = "alice@example.com"
}

$hashTable = [hashtable]$person

Write-Output $hashTable['Name']  # 输出 Alice
```

##### 2 转换为字符串 (JSON)

你可以将 `PSCustomObject` 转换为 JSON 字符串以便存储或传输：

```powershell
$person = [PSCustomObject]@{
    Name  = "Alice"
    Age   = 30
    Email = "alice@example.com"
}

$json = $person | ConvertTo-Json

Write-Output $json
```

##### 3 转换为 XML

`PSCustomObject` 也可以转换为 XML 格式：

```powershell
$person = [PSCustomObject]@{
    Name  = "Alice"
    Age   = 30
    Email = "alice@example.com"
}

$xml = $person | ConvertTo-Xml

Write-Output $xml.OuterXml
```

#### 5.3.3 类型转换的应用场景

- **数据存储**：可以将 `PSCustomObject` 转换为 JSON 或 XML 以便存储在文件中或传递给 Web 服务。
- **类型约束**：在函数或脚本中使用 `[PSCustomObject]` 类型约束，可以确保输入数据符合期望的结构。
- **数据操作**：将 `PSCustomObject` 转换为其他类型（如哈希表或字符串）便于进一步的数据操作或格式化。

### 5.4 类型转换的注意事项

- **数据丢失**：在转换过程中，某些类型的转换可能导致数据丢失或精度降低，例如将浮点数转换为整数时小数部分会被丢弃。
- **兼容性**：在处理复杂数据结构时，确保目标类型与源数据的结构兼容，以避免意外的错误或数据丢失。

### 5.5 示例：复杂的 `PSCustomObject` 类型转换

以下示例展示了如何将 `PSCustomObject` 与其他数据类型交互，并在数据结构之间进行转换：

```powershell
# 创建一个复杂的自定义对象
$employee = [PSCustomObject]@{
    Name       = "Charlie"
    Age        = 35
    Department = "Finance"
    Projects   = @(
                    [PSCustomObject]@{Name="Project A"; Budget=100000}
                    [PSCustomObject]@{Name="Project B"; Budget=150000}
                 )
}

# 转换为 JSON
$json = $employee | ConvertTo-Json
Write-Output "JSON Format:"
Write-Output $json

# 转换为哈希表
$hashTable = [hashtable]$employee
Write-Output "`nHashTable Format:"
Write-Output $hashTable

# 从 JSON 转换回 `PSCustomObject`
$employeeFromJson = $json | ConvertFrom-Json
Write-Output "`nObject from JSON:"
Write-Output $employeeFromJson
```

### 总结

类型转换是 PowerShell 中的一个关键概念，允许你在脚本中灵活处理和操作不同类型的数据。`PSCustomObject` 是 PowerShell 提供的强大工具，能够通过类型转换与其他数据结构（如哈希表、JSON、XML 等）无缝交互，从而简化数据处理任务。在使用类型转换时，需要注意目标类型的兼容性以及可能的数据丢失问题，以确保转换过程的正确性和可靠性。

## 6. 特殊变量

在 PowerShell 中，特殊变量（Special Variables）是由 PowerShell 自动定义和维护的变量，它们提供了与 PowerShell 环境、命令、脚本执行等相关的重要信息。以下是 PowerShell 中一些常见的特殊变量的详细介绍：

### 1. `$?` —— 最近命令的执行状态
`$?` 变量表示上一个命令是否成功执行。它是一个布尔值，如果上一个命令成功执行，则值为 `$true`，否则为 `$false`。

```powershell
Get-Item "C:\Windows"  # 如果成功执行
Write-Output $?         # 输出 True

Get-Item "C:\NonExistentFolder"  # 如果执行失败
Write-Output $?                  # 输出 False
```

### 2. `$_` 和 `$PSItem` —— 当前管道对象
`$_` 和 `$PSItem` 是 PowerShell 中的特殊变量，表示当前管道对象。在使用管道（`|`）时，这些变量代表管道中传递的每个对象。`$PSItem` 是 `$_` 的别名。

```powershell
# 示例：获取系统中的所有进程并输出其名称
Get-Process | ForEach-Object {
    Write-Output $_.Name
}

# 或者使用 $PSItem
Get-Process | ForEach-Object {
    Write-Output $PSItem.Name
}
```

### 3. `$^` —— 最近运行的命令
`$^` 变量包含最近运行的命令。这在需要快速重用上一个命令时非常有用。

```powershell
Get-Process  # 执行一个命令
Write-Output $^  # 输出 "Get-Process"
```

### 4. `$$` —— 最近运行的命令的最后一个参数
`$$` 变量保存了最近运行的命令的最后一个参数。

```powershell
Get-Process -Name "powershell"  # 执行一个命令
Write-Output $$  # 输出 "powershell"
```

### 5. `$LASTEXITCODE` —— 最近运行的命令的退出代码
`$LASTEXITCODE` 变量包含最近运行的命令的退出代码。它通常用于捕获外部程序的返回值。

```powershell
cmd /c exit 2  # 运行一个命令行命令，退出码为 2
Write-Output $LASTEXITCODE  # 输出 2
```

### 6. `$Error` —— 错误记录集合
`$Error` 变量是一个数组，包含最近发生的错误信息。最最近的错误在 `$Error[0]` 中。

```powershell
Get-Item "C:\NonExistentFolder"  # 触发一个错误
Write-Output $Error[0]           # 输出错误信息
```

### 7. `$Host` —— 当前的主机应用程序
`$Host` 变量表示当前运行 PowerShell 的主机应用程序，提供与主机相关的信息和方法。

```powershell
Write-Output $Host.Name  # 输出主机名称，例如 "ConsoleHost"
```

### 8. `$PROFILE` —— 当前用户的 PowerShell 配置文件路径
`$PROFILE` 变量表示当前用户的 PowerShell 配置文件的路径。你可以通过这个变量来管理 PowerShell 启动时自动加载的脚本。

```powershell
Write-Output $PROFILE  # 输出 PowerShell 配置文件的路径
```

### 9. `$PSVersionTable` —— PowerShell 版本信息
`$PSVersionTable` 变量是一个哈希表，包含当前 PowerShell 运行环境的版本和相关信息。

```powershell
Write-Output $PSVersionTable.PSVersion  # 输出 PowerShell 版本
```

### 10. `$Args` —— 脚本或函数的参数集合
`$Args` 变量是一个数组，包含传递给脚本或函数的未绑定参数。

```powershell
function Test-Args {
    param ($First, $Second)
    Write-Output $Args
}

Test-Args "One" "Two" "Three"  # 输出 "Three"
```

### 11. `$MyInvocation` —— 当前命令或脚本的调用信息
`$MyInvocation` 变量包含关于当前命令或脚本的调用信息，包括脚本名、参数、调用者等。

```powershell
Write-Output $MyInvocation.MyCommand.Name  # 输出当前脚本或函数的名称
```

### 12. `$PSScriptRoot` —— 当前脚本所在的目录
`$PSScriptRoot` 变量表示当前脚本所在的目录路径。这在脚本中引用相对路径时特别有用。

```powershell
Write-Output $PSScriptRoot  # 输出脚本所在目录路径
```

### 13. `$PWD` —— 当前工作目录
`$PWD` 变量表示当前的工作目录（路径对象），可以用于获取和显示当前所在的目录。

```powershell
Write-Output $PWD  # 输出当前工作目录路径
```

### 14. `$Input` —— 输入管道对象集合
`$Input` 变量表示所有通过管道传入的对象的集合。在使用 `Begin`, `Process`, `End` 脚本块时，它可以用于访问整个输入集合。

```powershell
$Input | ForEach-Object { Write-Output $_ }
```

### 15. `$OFS` —— 输出字段分隔符
`$OFS` 变量表示 `Write-Output` 和 `Out-String` 等命令用于连接数组或集合中的字符串元素时使用的分隔符。

```powershell
$OFS = ", "
$array = @("One", "Two", "Three")
Write-Output $array  # 输出 "One, Two, Three"
```

### 16. `$null` —— 空值
`$null` 是一个特殊变量，表示空值或无值。它通常用于清除变量、检查命令输出是否为空等。

```powershell
$var = $null
if ($var -eq $null) {
    Write-Output "变量为空"
}
```

### 17. `$True` 和 `$False` —— 布尔常量
`$True` 和 `$False` 是布尔常量，分别表示布尔值 `true` 和 `false`。

```powershell
if ($True) {
    Write-Output "这是一个布尔真值"
}
```

### 18. `$Matches` —— 正则表达式匹配结果
`$Matches` 变量是一个哈希表，存储最近使用 `-match` 运算符执行正则表达式匹配时的结果。

```powershell
$input = "Hello, PowerShell"
$input -match "Hello, (\w+)"
Write-Output $Matches[1]  # 输出 "PowerShell"
```

### 19. `$Input` —— 在函数或脚本块中代表输入管道
`$Input` 变量代表输入管道中的所有对象，在某些情况下（例如高级函数中的 `Begin` 和 `End` 脚本块）用于访问输入数据的集合。

### 20. `$StackTrace` —— 错误的堆栈跟踪信息
`$StackTrace` 变量提供最近的错误的堆栈跟踪信息，通常用于调试和排错。

```powershell
try {
    Get-Item "C:\NonExistentFolder"
}
catch {
    Write-Output $StackTrace  # 输出错误堆栈跟踪信息
}
```

### 21. `$Home` —— 当前用户的主目录
`$Home` 变量表示当前用户的主目录路径。

```powershell
Write-Output $Home  # 输出当前用户的主目录路径
```

### 22. `$ExecutionContext` —— 提供对当前运行环境的访问
`$ExecutionContext` 变量提供对 PowerShell 当前运行环境的访问，包括命令历史记录、会话状态等信息。

```powershell
Write-Output $ExecutionContext.SessionState.Path.CurrentLocation
```

### 23. `$ErrorActionPreference` —— 错误处理行为
`$ErrorActionPreference` 变量控制命令遇到错误时的行为，可能的值包括 `Continue`（默认）、`Stop`、`SilentlyContinue`、`Inquire` 等。

```powershell
$ErrorActionPreference = "Stop"
Get-Item "C:\NonExistentFolder"  # 遇到错误时立即停止执行
```

### 24. `$PSCmdlet` —— 提供对当前 cmdlet 的访问
`$PSCmdlet` 变量在高级函数或脚本中使用，提供对当前 cmdlet 上下文的访问，包括参数绑定、输出流等。

```powershell
function Test-PSCmdlet {
    [CmdletBinding()]
    param ()

    Write-Output $PSCmdlet.MyInvocation.MyCommand.Name
}
Test-PSCmdlet  # 输出 "Test-PSCmdlet"
```

### 25. `$This` —— 当前类实例的引用
在定义 PowerShell 类时，`$This` 变量用于引用当前类的实例。

`$This` 是 PowerShell 中的一个特殊变量，用于在类定义中引用当前类的实例。它类似于其他面向对象编程语言中的 `this` 关键字，指向正在执行的方法或属性所属的对象实例。

#### 详细解释：

在 PowerShell 中，类（`class`）是一种结构，它允许你定义对象的蓝图或模板。一个类可以包含属性（数据成员）和方法（函数成员）。当你实例化一个类时，你会创建一个对象，该对象可以使用类中定义的属性和方法。

`$This` 变量在类的方法或属性中使用时，指向当前对象实例，即它可以访问该实例的所有成员（属性和方法）。这使得 `$This` 变量非常有用，特别是在需要访问或修改当前实例的属性或调用当前实例的其他方法时。

#### 用法示例：

```powershell
# 定义一个类
class MyClass {
    # 定义一个属性
    [string]$Name
    
    # 定义一个构造函数
    MyClass([string]$name) {
        $This.Name = $name  # 使用 $This 设置当前实例的 Name 属性
    }
    
    # 定义一个方法
    [void]Greet() {
        Write-Output "Hello, my name is $($This.Name)."  # 使用 $This 访问当前实例的 Name 属性
    }
}

# 实例化该类
$instance = [MyClass]::new("Alice")

# 调用该实例的方法
$instance.Greet()
```
：

1. **类定义和属性：** `MyClass` 是一个类，包含一个字符串属性 `Name`。

2. **构造函数：** `MyClass([string]$name)` 是构造函数，用于在创建类实例时初始化 `Name` 属性。这里使用 `$This.Name = $name`，即通过 `$This` 访问当前实例的 `Name` 属性并赋值。

3. **方法：** `Greet()` 是一个方法，用于输出当前实例的 `Name`。通过 `$This.Name` 访问当前实例的 `Name` 属性，并输出一条问候语。

4. **实例化和调用：** 创建类的实例 `$instance`，并传递 `"Alice"` 作为参数。然后，调用该实例的 `Greet()` 方法，输出 `"Hello, my name is Alice."`。

#### 关键点：

- **`$This` 作用域：** `$This` 只能在类的方法或属性中使用，指向当前类实例。它不能在类的外部使用。

- **访问和修改属性：** `$This` 允许你在方法或属性中访问或修改同一对象的其他属性和方法。

- **代码复用和封装：** `$This` 提供了一种方式来封装对象内部的行为，使代码更加模块化和可维护。

#### 类似功能的参考：

在其他编程语言中，如 C#、JavaScript、Python 等，`this` 关键字有类似的用途，用于引用当前对象的实例。

## 表格

| 变量名称             | 含义与用途                                                                 | 示例                                                     |
|----------------------|----------------------------------------------------------------------------|----------------------------------------------------------|
| `$?`                 | 表示上一个命令的执行状态，成功为 `$true`，失败为 `$false`                 | `Get-Item "C:\Windows"` 运行后，`$?` 为 `$true`          |
| `$_` / `$PSItem`     | 当前管道对象，常用于管道处理中的 `ForEach-Object`、`Where-Object`          | `Get-Process | ForEach-Object { $_.Name }`                |
| `$^`                 | 最近运行的命令                                                             | 运行 `Get-Process` 后，`$^` 输出 `"Get-Process"`         |
| `$$`                 | 最近运行的命令的最后一个参数                                               | 运行 `Get-Process -Name "powershell"` 后，`$$` 输出 `"powershell"` |
| `$LASTEXITCODE`      | 最近运行的外部命令的退出代码                                               | `cmd /c exit 2` 后，`$LASTEXITCODE` 输出 `2`             |
| `$Error`             | 错误记录集合，包含最近的错误信息                                           | `Get-Item "C:\NonExistentFolder"` 后，`$Error[0]` 包含错误信息 |
| `$Host`              | 当前 PowerShell 主机应用程序的相关信息                                     | `$Host.Name` 可能输出 `"ConsoleHost"`                    |
| `$PROFILE`           | 当前用户的 PowerShell 配置文件路径                                         | `$PROFILE` 输出配置文件路径                               |
| `$PSVersionTable`    | 当前 PowerShell 版本和相关信息                                             | `$PSVersionTable.PSVersion` 输出 PowerShell 版本         |
| `$Args`              | 脚本或函数的未绑定参数集合                                                 | `Test-Args "One" "Two" "Three"` 中 `$Args` 输出 `"Three"`|
| `$MyInvocation`      | 当前命令或脚本的调用信息                                                   | `$MyInvocation.MyCommand.Name` 输出当前脚本名称          |
| `$PSScriptRoot`      | 当前脚本所在的目录路径                                                     | `$PSScriptRoot` 输出脚本所在目录                         |
| `$PWD`               | 当前工作目录路径                                                           | `$PWD` 输出当前目录路径                                   |
| `$Input`             | 输入管道对象集合，常用于 `Begin` 和 `End` 脚本块中                         | `$Input | ForEach-Object { $_ }`                          |
| `$OFS`               | 输出字段分隔符，用于连接数组中的字符串元素                                 | `$OFS = ", "` 后，`$array = @("One", "Two")` 输出 `"One, Two"` |
| `$null`              | 空值或无值，常用于变量清除或检查                                           | `$var = $null`                                           |
| `$True` / `$False`   | 布尔常量，表示布尔值 `true` 或 `false`                                     | `if ($True) { "True" }` 输出 `"True"`                   |
| `$Matches`           | 正则表达式匹配结果的哈希表，`-match` 运算符使用时生成                      | `"Hello" -match "H(.*)o"` 后，`$Matches[1]` 输出 `"ell"`|
| `$ErrorActionPreference` | 控制命令遇到错误时的行为，值包括 `Continue`、`Stop` 等                  | `$ErrorActionPreference = "Stop"`                        |
| `$Home`              | 当前用户的主目录路径                                                       | `$Home` 输出用户主目录路径                                |
| `$ExecutionContext`  | 提供对当前 PowerShell 运行环境的访问，包括命令历史记录等                    | `$ExecutionContext.SessionState.Path.CurrentLocation` 输出当前路径 |
| `$PSCmdlet`          | 提供对当前 cmdlet 的上下文访问，常用于高级函数中                           | `$PSCmdlet.MyInvocation.MyCommand.Name` 输出函数名称     |
| `$This`              | 引用当前 PowerShell 类的实例，常用于类定义中                               | `class MyClass { [void]Method() { $This } }`             |


## 示例
以下示例展示了变量和数据类型的使用。

```powershell
# 声明和赋值
$greeting = "Hello, World!"
$age = 25
$isAdmin = $true

# 变量作用域
$global:globalVar = "I am global"
$script:scriptVar = "I am script-wide"

function Test-Scope {
    $local:localVar = "I am local"
    Write-Output $localVar
    Write-Output $scriptVar
    Write-Output $globalVar
}

Test-Scope

# 数组和哈希表
$numbers = 1, 2, 3, 4, 5
Write-Output $numbers[0]

$person = @{
    FirstName = "Alice"
    LastName = "Smith"
    Age = 28
}
Write-Output $person["FirstName"]

# 类型转换
$numberString = "456"
$number = [int]$numberString
Write-Output $number

$booleanString = "False"
$boolean = [bool]$booleanString
Write-Output $boolean
```

通过以上内容，可以全面了解 PowerShell 中变量和数据类型的使用及其特点。